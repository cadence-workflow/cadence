// The MIT License (MIT)
//
// Copyright (c) 2020 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go

// Package processing is a generated GoMock package.
package processing

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	persistence "github.com/uber/cadence/common/persistence"
	task "github.com/uber/cadence/service/history/task"
)

// MockJobInfo is a mock of JobInfo interface
type MockJobInfo struct {
	ctrl     *gomock.Controller
	recorder *MockJobInfoMockRecorder
}

// MockJobInfoMockRecorder is the mock recorder for MockJobInfo
type MockJobInfoMockRecorder struct {
	mock *MockJobInfo
}

// NewMockJobInfo creates a new mock instance
func NewMockJobInfo(ctrl *gomock.Controller) *MockJobInfo {
	mock := &MockJobInfo{ctrl: ctrl}
	mock.recorder = &MockJobInfoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockJobInfo) EXPECT() *MockJobInfoMockRecorder {
	return m.recorder
}

// QueueID mocks base method
func (m *MockJobInfo) QueueID() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueID")
	ret0, _ := ret[0].(int)
	return ret0
}

// QueueID indicates an expected call of QueueID
func (mr *MockJobInfoMockRecorder) QueueID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueID", reflect.TypeOf((*MockJobInfo)(nil).QueueID))
}

// MinLevel mocks base method
func (m *MockJobInfo) MinLevel() task.Key {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MinLevel")
	ret0, _ := ret[0].(task.Key)
	return ret0
}

// MinLevel indicates an expected call of MinLevel
func (mr *MockJobInfoMockRecorder) MinLevel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MinLevel", reflect.TypeOf((*MockJobInfo)(nil).MinLevel))
}

// MaxLevel mocks base method
func (m *MockJobInfo) MaxLevel() task.Key {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MaxLevel")
	ret0, _ := ret[0].(task.Key)
	return ret0
}

// MaxLevel indicates an expected call of MaxLevel
func (mr *MockJobInfoMockRecorder) MaxLevel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MaxLevel", reflect.TypeOf((*MockJobInfo)(nil).MaxLevel))
}

// AckLevel mocks base method
func (m *MockJobInfo) AckLevel() task.Key {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AckLevel")
	ret0, _ := ret[0].(task.Key)
	return ret0
}

// AckLevel indicates an expected call of AckLevel
func (mr *MockJobInfoMockRecorder) AckLevel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AckLevel", reflect.TypeOf((*MockJobInfo)(nil).AckLevel))
}

// ReadLevel mocks base method
func (m *MockJobInfo) ReadLevel() task.Key {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadLevel")
	ret0, _ := ret[0].(task.Key)
	return ret0
}

// ReadLevel indicates an expected call of ReadLevel
func (mr *MockJobInfoMockRecorder) ReadLevel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadLevel", reflect.TypeOf((*MockJobInfo)(nil).ReadLevel))
}

// DomainFilter mocks base method
func (m *MockJobInfo) DomainFilter() DomainFilter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DomainFilter")
	ret0, _ := ret[0].(DomainFilter)
	return ret0
}

// DomainFilter indicates an expected call of DomainFilter
func (mr *MockJobInfoMockRecorder) DomainFilter() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DomainFilter", reflect.TypeOf((*MockJobInfo)(nil).DomainFilter))
}

// MockJob is a mock of Job interface
type MockJob struct {
	ctrl     *gomock.Controller
	recorder *MockJobMockRecorder
}

// MockJobMockRecorder is the mock recorder for MockJob
type MockJobMockRecorder struct {
	mock *MockJob
}

// NewMockJob creates a new mock instance
func NewMockJob(ctrl *gomock.Controller) *MockJob {
	mock := &MockJob{ctrl: ctrl}
	mock.recorder = &MockJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockJob) EXPECT() *MockJobMockRecorder {
	return m.recorder
}

// Info mocks base method
func (m *MockJob) Info() JobInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info")
	ret0, _ := ret[0].(JobInfo)
	return ret0
}

// Info indicates an expected call of Info
func (mr *MockJobMockRecorder) Info() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockJob)(nil).Info))
}

// Split mocks base method
func (m *MockJob) Split(arg0 JobSplitPolicy) []Job {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Split", arg0)
	ret0, _ := ret[0].([]Job)
	return ret0
}

// Split indicates an expected call of Split
func (mr *MockJobMockRecorder) Split(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Split", reflect.TypeOf((*MockJob)(nil).Split), arg0)
}

// Merge mocks base method
func (m *MockJob) Merge(arg0 Job) []Job {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Merge", arg0)
	ret0, _ := ret[0].([]Job)
	return ret0
}

// Merge indicates an expected call of Merge
func (mr *MockJobMockRecorder) Merge(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Merge", reflect.TypeOf((*MockJob)(nil).Merge), arg0)
}

// AddTasks mocks base method
func (m *MockJob) AddTasks(arg0 map[task.Key]task.Task) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddTasks", arg0)
}

// AddTasks indicates an expected call of AddTasks
func (mr *MockJobMockRecorder) AddTasks(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddTasks", reflect.TypeOf((*MockJob)(nil).AddTasks), arg0)
}

// UpdateAckLevel mocks base method
func (m *MockJob) UpdateAckLevel() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateAckLevel")
}

// UpdateAckLevel indicates an expected call of UpdateAckLevel
func (mr *MockJobMockRecorder) UpdateAckLevel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAckLevel", reflect.TypeOf((*MockJob)(nil).UpdateAckLevel))
}

// MockJobSplitPolicy is a mock of JobSplitPolicy interface
type MockJobSplitPolicy struct {
	ctrl     *gomock.Controller
	recorder *MockJobSplitPolicyMockRecorder
}

// MockJobSplitPolicyMockRecorder is the mock recorder for MockJobSplitPolicy
type MockJobSplitPolicyMockRecorder struct {
	mock *MockJobSplitPolicy
}

// NewMockJobSplitPolicy creates a new mock instance
func NewMockJobSplitPolicy(ctrl *gomock.Controller) *MockJobSplitPolicy {
	mock := &MockJobSplitPolicy{ctrl: ctrl}
	mock.recorder = &MockJobSplitPolicyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockJobSplitPolicy) EXPECT() *MockJobSplitPolicyMockRecorder {
	return m.recorder
}

// Evaluate mocks base method
func (m *MockJobSplitPolicy) Evaluate(arg0 Job) []JobInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Evaluate", arg0)
	ret0, _ := ret[0].([]JobInfo)
	return ret0
}

// Evaluate indicates an expected call of Evaluate
func (mr *MockJobSplitPolicyMockRecorder) Evaluate(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Evaluate", reflect.TypeOf((*MockJobSplitPolicy)(nil).Evaluate), arg0)
}

// MockJobQueue is a mock of JobQueue interface
type MockJobQueue struct {
	ctrl     *gomock.Controller
	recorder *MockJobQueueMockRecorder
}

// MockJobQueueMockRecorder is the mock recorder for MockJobQueue
type MockJobQueueMockRecorder struct {
	mock *MockJobQueue
}

// NewMockJobQueue creates a new mock instance
func NewMockJobQueue(ctrl *gomock.Controller) *MockJobQueue {
	mock := &MockJobQueue{ctrl: ctrl}
	mock.recorder = &MockJobQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockJobQueue) EXPECT() *MockJobQueueMockRecorder {
	return m.recorder
}

// Info mocks base method
func (m *MockJobQueue) Info() []JobInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info")
	ret0, _ := ret[0].([]JobInfo)
	return ret0
}

// Info indicates an expected call of Info
func (mr *MockJobQueueMockRecorder) Info() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockJobQueue)(nil).Info))
}

// Split mocks base method
func (m *MockJobQueue) Split(arg0 JobSplitPolicy) []Job {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Split", arg0)
	ret0, _ := ret[0].([]Job)
	return ret0
}

// Split indicates an expected call of Split
func (mr *MockJobQueueMockRecorder) Split(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Split", reflect.TypeOf((*MockJobQueue)(nil).Split), arg0)
}

// Merge mocks base method
func (m *MockJobQueue) Merge(arg0 []Job) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Merge", arg0)
}

// Merge indicates an expected call of Merge
func (mr *MockJobQueueMockRecorder) Merge(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Merge", reflect.TypeOf((*MockJobQueue)(nil).Merge), arg0)
}

// AddTasks mocks base method
func (m *MockJobQueue) AddTasks(arg0 map[task.Key]task.Task) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddTasks", arg0)
}

// AddTasks indicates an expected call of AddTasks
func (mr *MockJobQueueMockRecorder) AddTasks(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddTasks", reflect.TypeOf((*MockJobQueue)(nil).AddTasks), arg0)
}

// ActiveJob mocks base method
func (m *MockJobQueue) ActiveJob() Job {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActiveJob")
	ret0, _ := ret[0].(Job)
	return ret0
}

// ActiveJob indicates an expected call of ActiveJob
func (mr *MockJobQueueMockRecorder) ActiveJob() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActiveJob", reflect.TypeOf((*MockJobQueue)(nil).ActiveJob))
}

// MockJobQueueManager is a mock of JobQueueManager interface
type MockJobQueueManager struct {
	ctrl     *gomock.Controller
	recorder *MockJobQueueManagerMockRecorder
}

// MockJobQueueManagerMockRecorder is the mock recorder for MockJobQueueManager
type MockJobQueueManagerMockRecorder struct {
	mock *MockJobQueueManager
}

// NewMockJobQueueManager creates a new mock instance
func NewMockJobQueueManager(ctrl *gomock.Controller) *MockJobQueueManager {
	mock := &MockJobQueueManager{ctrl: ctrl}
	mock.recorder = &MockJobQueueManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockJobQueueManager) EXPECT() *MockJobQueueManagerMockRecorder {
	return m.recorder
}

// Start mocks base method
func (m *MockJobQueueManager) Start() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start
func (mr *MockJobQueueManagerMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockJobQueueManager)(nil).Start))
}

// Stop mocks base method
func (m *MockJobQueueManager) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop
func (mr *MockJobQueueManagerMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockJobQueueManager)(nil).Stop))
}

// NotifyNewTasks mocks base method
func (m *MockJobQueueManager) NotifyNewTasks(arg0 []persistence.Task) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "NotifyNewTasks", arg0)
}

// NotifyNewTasks indicates an expected call of NotifyNewTasks
func (mr *MockJobQueueManagerMockRecorder) NotifyNewTasks(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotifyNewTasks", reflect.TypeOf((*MockJobQueueManager)(nil).NotifyNewTasks), arg0)
}
