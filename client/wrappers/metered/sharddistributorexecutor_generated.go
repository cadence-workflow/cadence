package metered

// Code generated by gowrap. DO NOT EDIT.
// template: ../../templates/metered.tmpl
// gowrap: http://github.com/hexdigest/gowrap

import (
	"context"

	"go.uber.org/yarpc"

	"github.com/uber/cadence/client/sharddistributorexecutor"
	"github.com/uber/cadence/common/metrics"
	"github.com/uber/cadence/common/types"
)

// sharddistributorexecutorClient implements sharddistributorexecutor.Client interface instrumented with retries
type sharddistributorexecutorClient struct {
	client        sharddistributorexecutor.Client
	metricsClient metrics.Client
}

// NewShardDistributorExecutorClient creates a new instance of sharddistributorexecutorClient with retry policy
func NewShardDistributorExecutorClient(client sharddistributorexecutor.Client, metricsClient metrics.Client) sharddistributorexecutor.Client {
	return &sharddistributorexecutorClient{
		client:        client,
		metricsClient: metricsClient,
	}
}

func (c *sharddistributorexecutorClient) Heartbeat(ctx context.Context, ep1 *types.ExecutorHeartbeatRequest, p1 ...yarpc.CallOption) (ep2 *types.ExecutorHeartbeatResponse, err error) {
	retryCount := getRetryCountFromContext(ctx)

	var scope metrics.Scope
	if retryCount == -1 {
		scope = c.metricsClient.Scope(metrics.ShardDistributorExecutorClientHeartbeatScope)
	} else {
		scope = c.metricsClient.Scope(metrics.ShardDistributorExecutorClientHeartbeatScope, metrics.IsRetryTag(retryCount > 0))
	}

	scope.IncCounter(metrics.CadenceClientRequests)

	sw := scope.StartTimer(metrics.CadenceClientLatency)
	ep2, err = c.client.Heartbeat(ctx, ep1, p1...)
	sw.Stop()

	if err != nil {
		scope.IncCounter(metrics.CadenceClientFailures)
	}
	return ep2, err
}
