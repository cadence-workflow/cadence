// The MIT License (MIT)

// Copyright (c) 2017-2020 Uber Technologies Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package frontend

// Code generated by gowrap. DO NOT EDIT.
// template: templates/accesscontrolled.tmpl
// gowrap: http://github.com/hexdigest/gowrap

import (
	"context"

	"github.com/uber/cadence/common/authorization"
	"github.com/uber/cadence/common/config"
	"github.com/uber/cadence/common/log/tag"
	"github.com/uber/cadence/common/resource"
	"github.com/uber/cadence/common/types"
)

// accesscontrolledAdminHandler frontend handler wrapper for authentication and authorization
type accesscontrolledAdminHandler struct {
	handler    AdminHandler
	authorizer authorization.Authorizer
	resource.Resource
}

// NewAccessControlledAdminHandler creates frontend handler with authentication support
func NewAccessControlledAdminHandler(handler AdminHandler, resource resource.Resource, authorizer authorization.Authorizer, cfg config.Authorization) AdminHandler {
	if authorizer == nil {
		var err error
		authorizer, err = authorization.NewAuthorizer(cfg, resource.GetLogger(), resource.GetDomainCache())
		if err != nil {
			resource.GetLogger().Fatal("Error when initiating the Authorizer", tag.Error(err))
		}
	}
	return &accesscontrolledAdminHandler{
		handler:    handler,
		authorizer: authorizer,
		Resource:   resource,
	}
}

func (a *accesscontrolledAdminHandler) AddSearchAttribute(ctx context.Context, ap1 *types.AddSearchAttributeRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "AddSearchAttribute",
		Permission:  authorization.PermissionAdmin,
		RequestBody: ap1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.AddSearchAttribute(ctx, ap1)
}

func (a *accesscontrolledAdminHandler) CloseShard(ctx context.Context, cp1 *types.CloseShardRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "CloseShard",
		Permission:  authorization.PermissionAdmin,
		RequestBody: cp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.CloseShard(ctx, cp1)
}

func (a *accesscontrolledAdminHandler) CountDLQMessages(ctx context.Context, cp1 *types.CountDLQMessagesRequest) (cp2 *types.CountDLQMessagesResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "CountDLQMessages",
		Permission:  authorization.PermissionAdmin,
		RequestBody: cp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.CountDLQMessages(ctx, cp1)
}

func (a *accesscontrolledAdminHandler) DeleteWorkflow(ctx context.Context, ap1 *types.AdminDeleteWorkflowRequest) (ap2 *types.AdminDeleteWorkflowResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "DeleteWorkflow",
		Permission:  authorization.PermissionAdmin,
		RequestBody: ap1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.DeleteWorkflow(ctx, ap1)
}

func (a *accesscontrolledAdminHandler) DescribeCluster(ctx context.Context) (dp1 *types.DescribeClusterResponse, err error) {
	attr := &authorization.Attributes{
		APIName:    "DescribeCluster",
		Permission: authorization.PermissionAdmin,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.DescribeCluster(ctx)
}

func (a *accesscontrolledAdminHandler) DescribeHistoryHost(ctx context.Context, dp1 *types.DescribeHistoryHostRequest) (dp2 *types.DescribeHistoryHostResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "DescribeHistoryHost",
		Permission:  authorization.PermissionAdmin,
		RequestBody: dp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.DescribeHistoryHost(ctx, dp1)
}

func (a *accesscontrolledAdminHandler) DescribeQueue(ctx context.Context, dp1 *types.DescribeQueueRequest) (dp2 *types.DescribeQueueResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "DescribeQueue",
		Permission:  authorization.PermissionAdmin,
		RequestBody: dp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.DescribeQueue(ctx, dp1)
}

func (a *accesscontrolledAdminHandler) DescribeShardDistribution(ctx context.Context, dp1 *types.DescribeShardDistributionRequest) (dp2 *types.DescribeShardDistributionResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "DescribeShardDistribution",
		Permission:  authorization.PermissionAdmin,
		RequestBody: dp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.DescribeShardDistribution(ctx, dp1)
}

func (a *accesscontrolledAdminHandler) DescribeWorkflowExecution(ctx context.Context, ap1 *types.AdminDescribeWorkflowExecutionRequest) (ap2 *types.AdminDescribeWorkflowExecutionResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "DescribeWorkflowExecution",
		Permission:  authorization.PermissionAdmin,
		RequestBody: ap1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.DescribeWorkflowExecution(ctx, ap1)
}

func (a *accesscontrolledAdminHandler) GetCrossClusterTasks(ctx context.Context, gp1 *types.GetCrossClusterTasksRequest) (gp2 *types.GetCrossClusterTasksResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetCrossClusterTasks",
		Permission:  authorization.PermissionAdmin,
		RequestBody: gp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetCrossClusterTasks(ctx, gp1)
}

func (a *accesscontrolledAdminHandler) GetDLQReplicationMessages(ctx context.Context, gp1 *types.GetDLQReplicationMessagesRequest) (gp2 *types.GetDLQReplicationMessagesResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetDLQReplicationMessages",
		Permission:  authorization.PermissionAdmin,
		RequestBody: gp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetDLQReplicationMessages(ctx, gp1)
}

func (a *accesscontrolledAdminHandler) GetDomainIsolationGroups(ctx context.Context, request *types.GetDomainIsolationGroupsRequest) (gp1 *types.GetDomainIsolationGroupsResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetDomainIsolationGroups",
		Permission:  authorization.PermissionAdmin,
		RequestBody: request,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetDomainIsolationGroups(ctx, request)
}

func (a *accesscontrolledAdminHandler) GetDomainReplicationMessages(ctx context.Context, gp1 *types.GetDomainReplicationMessagesRequest) (gp2 *types.GetDomainReplicationMessagesResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetDomainReplicationMessages",
		Permission:  authorization.PermissionAdmin,
		RequestBody: gp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetDomainReplicationMessages(ctx, gp1)
}

func (a *accesscontrolledAdminHandler) GetDynamicConfig(ctx context.Context, gp1 *types.GetDynamicConfigRequest) (gp2 *types.GetDynamicConfigResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetDynamicConfig",
		Permission:  authorization.PermissionAdmin,
		RequestBody: gp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetDynamicConfig(ctx, gp1)
}

func (a *accesscontrolledAdminHandler) GetGlobalIsolationGroups(ctx context.Context, request *types.GetGlobalIsolationGroupsRequest) (gp1 *types.GetGlobalIsolationGroupsResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetGlobalIsolationGroups",
		Permission:  authorization.PermissionAdmin,
		RequestBody: request,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetGlobalIsolationGroups(ctx, request)
}

func (a *accesscontrolledAdminHandler) GetReplicationMessages(ctx context.Context, gp1 *types.GetReplicationMessagesRequest) (gp2 *types.GetReplicationMessagesResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetReplicationMessages",
		Permission:  authorization.PermissionAdmin,
		RequestBody: gp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetReplicationMessages(ctx, gp1)
}

func (a *accesscontrolledAdminHandler) GetWorkflowExecutionRawHistoryV2(ctx context.Context, gp1 *types.GetWorkflowExecutionRawHistoryV2Request) (gp2 *types.GetWorkflowExecutionRawHistoryV2Response, err error) {
	attr := &authorization.Attributes{
		APIName:     "GetWorkflowExecutionRawHistoryV2",
		Permission:  authorization.PermissionAdmin,
		RequestBody: gp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.GetWorkflowExecutionRawHistoryV2(ctx, gp1)
}

func (a *accesscontrolledAdminHandler) ListDynamicConfig(ctx context.Context, lp1 *types.ListDynamicConfigRequest) (lp2 *types.ListDynamicConfigResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "ListDynamicConfig",
		Permission:  authorization.PermissionAdmin,
		RequestBody: lp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.ListDynamicConfig(ctx, lp1)
}

func (a *accesscontrolledAdminHandler) MaintainCorruptWorkflow(ctx context.Context, ap1 *types.AdminMaintainWorkflowRequest) (ap2 *types.AdminMaintainWorkflowResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "MaintainCorruptWorkflow",
		Permission:  authorization.PermissionAdmin,
		RequestBody: ap1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.MaintainCorruptWorkflow(ctx, ap1)
}

func (a *accesscontrolledAdminHandler) MergeDLQMessages(ctx context.Context, mp1 *types.MergeDLQMessagesRequest) (mp2 *types.MergeDLQMessagesResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "MergeDLQMessages",
		Permission:  authorization.PermissionAdmin,
		RequestBody: mp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.MergeDLQMessages(ctx, mp1)
}

func (a *accesscontrolledAdminHandler) PurgeDLQMessages(ctx context.Context, pp1 *types.PurgeDLQMessagesRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "PurgeDLQMessages",
		Permission:  authorization.PermissionAdmin,
		RequestBody: pp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.PurgeDLQMessages(ctx, pp1)
}

func (a *accesscontrolledAdminHandler) ReadDLQMessages(ctx context.Context, rp1 *types.ReadDLQMessagesRequest) (rp2 *types.ReadDLQMessagesResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "ReadDLQMessages",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.ReadDLQMessages(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) ReapplyEvents(ctx context.Context, rp1 *types.ReapplyEventsRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "ReapplyEvents",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.ReapplyEvents(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) RefreshWorkflowTasks(ctx context.Context, rp1 *types.RefreshWorkflowTasksRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "RefreshWorkflowTasks",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.RefreshWorkflowTasks(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) RemoveTask(ctx context.Context, rp1 *types.RemoveTaskRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "RemoveTask",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.RemoveTask(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) ResendReplicationTasks(ctx context.Context, rp1 *types.ResendReplicationTasksRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "ResendReplicationTasks",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.ResendReplicationTasks(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) ResetQueue(ctx context.Context, rp1 *types.ResetQueueRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "ResetQueue",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.ResetQueue(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) RespondCrossClusterTasksCompleted(ctx context.Context, rp1 *types.RespondCrossClusterTasksCompletedRequest) (rp2 *types.RespondCrossClusterTasksCompletedResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "RespondCrossClusterTasksCompleted",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.RespondCrossClusterTasksCompleted(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) RestoreDynamicConfig(ctx context.Context, rp1 *types.RestoreDynamicConfigRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "RestoreDynamicConfig",
		Permission:  authorization.PermissionAdmin,
		RequestBody: rp1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.RestoreDynamicConfig(ctx, rp1)
}

func (a *accesscontrolledAdminHandler) Start() {
	a.handler.Start()
}

func (a *accesscontrolledAdminHandler) Stop() {
	a.handler.Stop()
}

func (a *accesscontrolledAdminHandler) UpdateDomainIsolationGroups(ctx context.Context, request *types.UpdateDomainIsolationGroupsRequest) (up1 *types.UpdateDomainIsolationGroupsResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "UpdateDomainIsolationGroups",
		Permission:  authorization.PermissionAdmin,
		RequestBody: request,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.UpdateDomainIsolationGroups(ctx, request)
}

func (a *accesscontrolledAdminHandler) UpdateDynamicConfig(ctx context.Context, up1 *types.UpdateDynamicConfigRequest) (err error) {
	attr := &authorization.Attributes{
		APIName:     "UpdateDynamicConfig",
		Permission:  authorization.PermissionAdmin,
		RequestBody: up1,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return err
	}
	if !isAuthorized {
		return errUnauthorized
	}
	return a.handler.UpdateDynamicConfig(ctx, up1)
}

func (a *accesscontrolledAdminHandler) UpdateGlobalIsolationGroups(ctx context.Context, request *types.UpdateGlobalIsolationGroupsRequest) (up1 *types.UpdateGlobalIsolationGroupsResponse, err error) {
	attr := &authorization.Attributes{
		APIName:     "UpdateGlobalIsolationGroups",
		Permission:  authorization.PermissionAdmin,
		RequestBody: request,
	}
	isAuthorized, err := a.isAuthorized(ctx, attr)
	if err != nil {
		return nil, err
	}
	if !isAuthorized {
		return nil, errUnauthorized
	}
	return a.handler.UpdateGlobalIsolationGroups(ctx, request)
}
