(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{409:function(e,t,a){"use strict";a.r(t);var o=a(8),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"cross-dc-replication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cross-dc-replication"}},[e._v("#")]),e._v(" Cross-DC replication")]),e._v(" "),a("p",[e._v("The Cadence Global :domain:Domain: feature provides clients with the capability to continue their :workflow_execution: from another\ncluster in the event of a datacenter failover. Although you can configure a Global :domain:Domain: to be replicated to any number of\nclusters, it is only considered active in a single cluster.")]),e._v(" "),a("h2",{attrs:{id:"global-domains-architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#global-domains-architecture"}},[e._v("#")]),e._v(" Global Domains Architecture")]),e._v(" "),a("p",[e._v("Cadence has introduced a new top level entity, Global :domain:Domains:, which provides support for replication of :workflow:\nexecution across clusters. Client applications need to run :worker:workers: polling on :activity:Activity:/:decision_task:Decision_tasks: on all clusters.\nCadence will only dispatch tasks on the current active cluster; :worker:workers: on the standby cluster will sit idle\nuntil the Global :domain:Domain: is failed over.")]),e._v(" "),a("p",[e._v("Because Cadence is a service that provides highly consistent semantics, we only allow external :event:events: like\n"),a("strong",[e._v("StartWorkflowExecution")]),e._v(", "),a("strong",[e._v("SignalWorkflowExecution")]),e._v(", etc. on an active cluster. Global :domain:Domains: relies on light-weight\ntransactions (paxos) on the local cluster (Local_Quorum) to update the :workflow_execution: state and create replication\n:task:tasks: which are applied asynchronously to replicate state across clusters. If an application makes these API calls on a\ncluster where Global :domain:Domain: is in standby mode, Cadence will reject those calls with "),a("strong",[e._v("DomainNotActiveError")]),e._v(", which\ncontains the name of the current active cluster. It is the responsibility of the application to forward the external\n:event: to the cluster that is currently active.")]),e._v(" "),a("h2",{attrs:{id:"new-config-for-global-domains"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-config-for-global-domains"}},[e._v("#")]),e._v(" New config for Global Domains")]),e._v(" "),a("h3",{attrs:{id:"isglobal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isglobal"}},[e._v("#")]),e._v(" IsGlobal")]),e._v(" "),a("p",[e._v("This config is used to distinguish :domain:domains: local to the cluster from the global :domain:. It controls the creation of\nreplication :task:tasks: on updates allowing the state to be replicated across clusters. This is a read-only setting that can\nonly be set when the :domain: is provisioned.")]),e._v(" "),a("h3",{attrs:{id:"clusters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clusters"}},[e._v("#")]),e._v(" Clusters")]),e._v(" "),a("p",[e._v("A list of clusters where the :domain: can fail over to, including the current active cluster.\nThis is also a read-only setting that can only be set when the :domain: is provisioned. A re-replication feature on the\nroadmap will allow updating this config to add/remove clusters in the future.")]),e._v(" "),a("h3",{attrs:{id:"active-cluster-name"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#active-cluster-name"}},[e._v("#")]),e._v(" Active Cluster Name")]),e._v(" "),a("p",[e._v("Name of the current active cluster for the Global :domain:Domain:. This config is updated each time the Global :domain:Domain: is failed over to\nanother cluster.")]),e._v(" "),a("h3",{attrs:{id:"failover-version"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failover-version"}},[e._v("#")]),e._v(" Failover Version")]),e._v(" "),a("p",[e._v("Unique failover version which also represents the current active cluster for Global :domain:Domain:. Cadence allows failover to\nbe triggered from any cluster, so failover version is designed in a way to not allow conflicts if failover is mistakenly\ntriggered simultaneously on two clusters.")]),e._v(" "),a("h2",{attrs:{id:"conflict-resolution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conflict-resolution"}},[e._v("#")]),e._v(" Conflict Resolution")]),e._v(" "),a("p",[e._v("Unlike local :domain:domains: which provide at-most-once semantics for :activity: execution, Global :domain:Domains: can only support at-least-once\nsemantics. Cadence XDC relies on asynchronous replication of :event:events: across clusters, so in the event of a failover\nit is possible that :activity: gets dispatched again on the new active cluster due to a replication :task: lag. This also\nmeans that whenever :workflow_execution: is updated after a failover by the new cluster, any previous replication :task:tasks:\nfor that execution cannot be applied. This results in loss of some progress made by the :workflow_execution: in the\nprevious active cluster. During such conflict resolution, Cadence re-injects any external :event:events: like :signal:Signals: to the\nnew history before discarding replication :task:tasks:. Even though some progress could rollback during failovers, Cadence\nprovides the guarantee that :workflow:workflows: wonâ€™t get stuck and will continue to make forward progress.")]),e._v(" "),a("h2",{attrs:{id:"visibility-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#visibility-api"}},[e._v("#")]),e._v(" Visibility API")]),e._v(" "),a("p",[e._v("All Visibility APIs are allowed on both active and standby clusters. This enables\n"),a("a",{attrs:{href:"https://github.com/uber/cadence-web",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cadence Web"),a("OutboundLink")],1),e._v(" to work seamlessly for Global :domain:Domains: as all visibility records for\n:workflow_execution:workflow_executions: can be queried from any cluster the :domain: is replicated to. Applications making API calls directly\nto the Cadence Visibility API will continue to work even if a Global :domain:Domain: is in standby mode. However, they might see\na lag due to replication delay when :query:querying: the :workflow_execution: state from a standby cluster.")]),e._v(" "),a("h2",{attrs:{id:"cli"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cli"}},[e._v("#")]),e._v(" CLI")]),e._v(" "),a("p",[e._v("The Cadence :CLI: can also be used to :query: the :domain: config or perform failovers. Here are some useful commands.")]),e._v(" "),a("h3",{attrs:{id:"query-global-domain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query-global-domain"}},[e._v("#")]),e._v(" Query Global Domain")]),e._v(" "),a("p",[e._v("The following command can be used to describe Global :domain:Domain: metadata:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ cadence --do cadence-canary-xdc d desc\nName: cadence-canary-xdc\nDescription: cadence canary cross "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("dc")]),e._v(" testing domain\nOwnerEmail: cadence-dev@cadenceworkflow.io\nDomainData:\nStatus: REGISTERED\nRetentionInDays: "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("7")]),e._v("\nEmitMetrics: "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\nActiveClusterName: dc1\nClusters: dc1, dc2\n")])])]),a("h3",{attrs:{id:"failover-global-domain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failover-global-domain"}},[e._v("#")]),e._v(" Failover Global Domain")]),e._v(" "),a("p",[e._v("The following command can be used to failover Global :domain:Domain: "),a("em",[e._v("my-domain-global")]),e._v(" to the "),a("em",[e._v("dc2")]),e._v(" cluster:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("$ cadence --do my-domain-global d up --ac dc2\n")])])]),a("h2",{attrs:{id:"faq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[e._v("#")]),e._v(" FAQ")]),e._v(" "),a("h3",{attrs:{id:"what-happens-to-outstanding-activities-after-failover"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-happens-to-outstanding-activities-after-failover"}},[e._v("#")]),e._v(" What happens to outstanding activities after failover?")]),e._v(" "),a("p",[e._v("Cadence does not forward :activity: completions across clusters. Any outstanding :activity: will eventually timeout based\non the configuration. Your application should have retry logic in place so that the :activity: gets retried and dispatched\nagain to a :worker: after the failover to the new DC. Handling this is pretty much the same as :activity: timeout caused by\na :worker: restart even without Global :domain:Domains:.")]),e._v(" "),a("h3",{attrs:{id:"what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster"}},[e._v("#")]),e._v(" What happens when a start or signal API call is made to a standby cluster?")]),e._v(" "),a("p",[e._v("Cadence will reject the call and return "),a("strong",[e._v("DomainNotActiveError")]),e._v(". It is the responsibility of the application to forward\nthe failed call to active cluster based on information provided in the error.")]),e._v(" "),a("h3",{attrs:{id:"what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster"}},[e._v("#")]),e._v(" What is the recommended pattern to send external events to an active cluster?")]),e._v(" "),a("p",[e._v("The recommendation at this point is to publish :event:events: to a Kafka topic if they can be generated in any DC.\nThen, have a consumer that consumes from the aggregated Kafka topic in the same DC and sends them to Cadence. Both the\nKafka consumer and Global :domain:Domain: need to be failed over together.")])])}),[],!1,null,null,null);t.default=n.exports}}]);