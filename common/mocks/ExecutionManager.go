// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	mock "github.com/stretchr/testify/mock"

	"github.com/uber/cadence/common/persistence"
	"github.com/uber/cadence/common/types"
)

// NewExecutionManager creates a new instance of ExecutionManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionManager {
	mock := &ExecutionManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExecutionManager is an autogenerated mock type for the ExecutionManager type
type ExecutionManager struct {
	mock.Mock
}

type ExecutionManager_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionManager) EXPECT() *ExecutionManager_Expecter {
	return &ExecutionManager_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) Close() {
	_mock.Called()
	return
}

// ExecutionManager_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type ExecutionManager_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *ExecutionManager_Expecter) Close() *ExecutionManager_Close_Call {
	return &ExecutionManager_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *ExecutionManager_Close_Call) Run(run func()) *ExecutionManager_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionManager_Close_Call) Return() *ExecutionManager_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *ExecutionManager_Close_Call) RunAndReturn(run func()) *ExecutionManager_Close_Call {
	_c.Run(run)
	return _c
}

// CompleteHistoryTask provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) CompleteHistoryTask(ctx context.Context, request *persistence.CompleteHistoryTaskRequest) error {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CompleteHistoryTask")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.CompleteHistoryTaskRequest) error); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionManager_CompleteHistoryTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteHistoryTask'
type ExecutionManager_CompleteHistoryTask_Call struct {
	*mock.Call
}

// CompleteHistoryTask is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.CompleteHistoryTaskRequest
func (_e *ExecutionManager_Expecter) CompleteHistoryTask(ctx interface{}, request interface{}) *ExecutionManager_CompleteHistoryTask_Call {
	return &ExecutionManager_CompleteHistoryTask_Call{Call: _e.mock.On("CompleteHistoryTask", ctx, request)}
}

func (_c *ExecutionManager_CompleteHistoryTask_Call) Run(run func(ctx context.Context, request *persistence.CompleteHistoryTaskRequest)) *ExecutionManager_CompleteHistoryTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.CompleteHistoryTaskRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.CompleteHistoryTaskRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_CompleteHistoryTask_Call) Return(err error) *ExecutionManager_CompleteHistoryTask_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionManager_CompleteHistoryTask_Call) RunAndReturn(run func(ctx context.Context, request *persistence.CompleteHistoryTaskRequest) error) *ExecutionManager_CompleteHistoryTask_Call {
	_c.Call.Return(run)
	return _c
}

// ConflictResolveWorkflowExecution provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) ConflictResolveWorkflowExecution(ctx context.Context, request *persistence.ConflictResolveWorkflowExecutionRequest) (*persistence.ConflictResolveWorkflowExecutionResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ConflictResolveWorkflowExecution")
	}

	var r0 *persistence.ConflictResolveWorkflowExecutionResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.ConflictResolveWorkflowExecutionRequest) (*persistence.ConflictResolveWorkflowExecutionResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.ConflictResolveWorkflowExecutionRequest) *persistence.ConflictResolveWorkflowExecutionResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.ConflictResolveWorkflowExecutionResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.ConflictResolveWorkflowExecutionRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_ConflictResolveWorkflowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConflictResolveWorkflowExecution'
type ExecutionManager_ConflictResolveWorkflowExecution_Call struct {
	*mock.Call
}

// ConflictResolveWorkflowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.ConflictResolveWorkflowExecutionRequest
func (_e *ExecutionManager_Expecter) ConflictResolveWorkflowExecution(ctx interface{}, request interface{}) *ExecutionManager_ConflictResolveWorkflowExecution_Call {
	return &ExecutionManager_ConflictResolveWorkflowExecution_Call{Call: _e.mock.On("ConflictResolveWorkflowExecution", ctx, request)}
}

func (_c *ExecutionManager_ConflictResolveWorkflowExecution_Call) Run(run func(ctx context.Context, request *persistence.ConflictResolveWorkflowExecutionRequest)) *ExecutionManager_ConflictResolveWorkflowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.ConflictResolveWorkflowExecutionRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.ConflictResolveWorkflowExecutionRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_ConflictResolveWorkflowExecution_Call) Return(conflictResolveWorkflowExecutionResponse *persistence.ConflictResolveWorkflowExecutionResponse, err error) *ExecutionManager_ConflictResolveWorkflowExecution_Call {
	_c.Call.Return(conflictResolveWorkflowExecutionResponse, err)
	return _c
}

func (_c *ExecutionManager_ConflictResolveWorkflowExecution_Call) RunAndReturn(run func(ctx context.Context, request *persistence.ConflictResolveWorkflowExecutionRequest) (*persistence.ConflictResolveWorkflowExecutionResponse, error)) *ExecutionManager_ConflictResolveWorkflowExecution_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFailoverMarkerTasks provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) CreateFailoverMarkerTasks(ctx context.Context, request *persistence.CreateFailoverMarkersRequest) error {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateFailoverMarkerTasks")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.CreateFailoverMarkersRequest) error); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionManager_CreateFailoverMarkerTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFailoverMarkerTasks'
type ExecutionManager_CreateFailoverMarkerTasks_Call struct {
	*mock.Call
}

// CreateFailoverMarkerTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.CreateFailoverMarkersRequest
func (_e *ExecutionManager_Expecter) CreateFailoverMarkerTasks(ctx interface{}, request interface{}) *ExecutionManager_CreateFailoverMarkerTasks_Call {
	return &ExecutionManager_CreateFailoverMarkerTasks_Call{Call: _e.mock.On("CreateFailoverMarkerTasks", ctx, request)}
}

func (_c *ExecutionManager_CreateFailoverMarkerTasks_Call) Run(run func(ctx context.Context, request *persistence.CreateFailoverMarkersRequest)) *ExecutionManager_CreateFailoverMarkerTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.CreateFailoverMarkersRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.CreateFailoverMarkersRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_CreateFailoverMarkerTasks_Call) Return(err error) *ExecutionManager_CreateFailoverMarkerTasks_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionManager_CreateFailoverMarkerTasks_Call) RunAndReturn(run func(ctx context.Context, request *persistence.CreateFailoverMarkersRequest) error) *ExecutionManager_CreateFailoverMarkerTasks_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowExecution provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) CreateWorkflowExecution(ctx context.Context, request *persistence.CreateWorkflowExecutionRequest) (*persistence.CreateWorkflowExecutionResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowExecution")
	}

	var r0 *persistence.CreateWorkflowExecutionResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.CreateWorkflowExecutionRequest) (*persistence.CreateWorkflowExecutionResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.CreateWorkflowExecutionRequest) *persistence.CreateWorkflowExecutionResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.CreateWorkflowExecutionResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.CreateWorkflowExecutionRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_CreateWorkflowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowExecution'
type ExecutionManager_CreateWorkflowExecution_Call struct {
	*mock.Call
}

// CreateWorkflowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.CreateWorkflowExecutionRequest
func (_e *ExecutionManager_Expecter) CreateWorkflowExecution(ctx interface{}, request interface{}) *ExecutionManager_CreateWorkflowExecution_Call {
	return &ExecutionManager_CreateWorkflowExecution_Call{Call: _e.mock.On("CreateWorkflowExecution", ctx, request)}
}

func (_c *ExecutionManager_CreateWorkflowExecution_Call) Run(run func(ctx context.Context, request *persistence.CreateWorkflowExecutionRequest)) *ExecutionManager_CreateWorkflowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.CreateWorkflowExecutionRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.CreateWorkflowExecutionRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_CreateWorkflowExecution_Call) Return(createWorkflowExecutionResponse *persistence.CreateWorkflowExecutionResponse, err error) *ExecutionManager_CreateWorkflowExecution_Call {
	_c.Call.Return(createWorkflowExecutionResponse, err)
	return _c
}

func (_c *ExecutionManager_CreateWorkflowExecution_Call) RunAndReturn(run func(ctx context.Context, request *persistence.CreateWorkflowExecutionRequest) (*persistence.CreateWorkflowExecutionResponse, error)) *ExecutionManager_CreateWorkflowExecution_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteActiveClusterSelectionPolicy provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) DeleteActiveClusterSelectionPolicy(ctx context.Context, domainID string, workflowID string, runID string) error {
	ret := _mock.Called(ctx, domainID, workflowID, runID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteActiveClusterSelectionPolicy")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, domainID, workflowID, runID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionManager_DeleteActiveClusterSelectionPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteActiveClusterSelectionPolicy'
type ExecutionManager_DeleteActiveClusterSelectionPolicy_Call struct {
	*mock.Call
}

// DeleteActiveClusterSelectionPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - workflowID string
//   - runID string
func (_e *ExecutionManager_Expecter) DeleteActiveClusterSelectionPolicy(ctx interface{}, domainID interface{}, workflowID interface{}, runID interface{}) *ExecutionManager_DeleteActiveClusterSelectionPolicy_Call {
	return &ExecutionManager_DeleteActiveClusterSelectionPolicy_Call{Call: _e.mock.On("DeleteActiveClusterSelectionPolicy", ctx, domainID, workflowID, runID)}
}

func (_c *ExecutionManager_DeleteActiveClusterSelectionPolicy_Call) Run(run func(ctx context.Context, domainID string, workflowID string, runID string)) *ExecutionManager_DeleteActiveClusterSelectionPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ExecutionManager_DeleteActiveClusterSelectionPolicy_Call) Return(err error) *ExecutionManager_DeleteActiveClusterSelectionPolicy_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionManager_DeleteActiveClusterSelectionPolicy_Call) RunAndReturn(run func(ctx context.Context, domainID string, workflowID string, runID string) error) *ExecutionManager_DeleteActiveClusterSelectionPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCurrentWorkflowExecution provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) DeleteCurrentWorkflowExecution(ctx context.Context, request *persistence.DeleteCurrentWorkflowExecutionRequest) error {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCurrentWorkflowExecution")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.DeleteCurrentWorkflowExecutionRequest) error); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionManager_DeleteCurrentWorkflowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCurrentWorkflowExecution'
type ExecutionManager_DeleteCurrentWorkflowExecution_Call struct {
	*mock.Call
}

// DeleteCurrentWorkflowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.DeleteCurrentWorkflowExecutionRequest
func (_e *ExecutionManager_Expecter) DeleteCurrentWorkflowExecution(ctx interface{}, request interface{}) *ExecutionManager_DeleteCurrentWorkflowExecution_Call {
	return &ExecutionManager_DeleteCurrentWorkflowExecution_Call{Call: _e.mock.On("DeleteCurrentWorkflowExecution", ctx, request)}
}

func (_c *ExecutionManager_DeleteCurrentWorkflowExecution_Call) Run(run func(ctx context.Context, request *persistence.DeleteCurrentWorkflowExecutionRequest)) *ExecutionManager_DeleteCurrentWorkflowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.DeleteCurrentWorkflowExecutionRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.DeleteCurrentWorkflowExecutionRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_DeleteCurrentWorkflowExecution_Call) Return(err error) *ExecutionManager_DeleteCurrentWorkflowExecution_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionManager_DeleteCurrentWorkflowExecution_Call) RunAndReturn(run func(ctx context.Context, request *persistence.DeleteCurrentWorkflowExecutionRequest) error) *ExecutionManager_DeleteCurrentWorkflowExecution_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteReplicationTaskFromDLQ provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) DeleteReplicationTaskFromDLQ(ctx context.Context, request *persistence.DeleteReplicationTaskFromDLQRequest) error {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteReplicationTaskFromDLQ")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.DeleteReplicationTaskFromDLQRequest) error); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionManager_DeleteReplicationTaskFromDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteReplicationTaskFromDLQ'
type ExecutionManager_DeleteReplicationTaskFromDLQ_Call struct {
	*mock.Call
}

// DeleteReplicationTaskFromDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.DeleteReplicationTaskFromDLQRequest
func (_e *ExecutionManager_Expecter) DeleteReplicationTaskFromDLQ(ctx interface{}, request interface{}) *ExecutionManager_DeleteReplicationTaskFromDLQ_Call {
	return &ExecutionManager_DeleteReplicationTaskFromDLQ_Call{Call: _e.mock.On("DeleteReplicationTaskFromDLQ", ctx, request)}
}

func (_c *ExecutionManager_DeleteReplicationTaskFromDLQ_Call) Run(run func(ctx context.Context, request *persistence.DeleteReplicationTaskFromDLQRequest)) *ExecutionManager_DeleteReplicationTaskFromDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.DeleteReplicationTaskFromDLQRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.DeleteReplicationTaskFromDLQRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_DeleteReplicationTaskFromDLQ_Call) Return(err error) *ExecutionManager_DeleteReplicationTaskFromDLQ_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionManager_DeleteReplicationTaskFromDLQ_Call) RunAndReturn(run func(ctx context.Context, request *persistence.DeleteReplicationTaskFromDLQRequest) error) *ExecutionManager_DeleteReplicationTaskFromDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflowExecution provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) DeleteWorkflowExecution(ctx context.Context, request *persistence.DeleteWorkflowExecutionRequest) error {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowExecution")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.DeleteWorkflowExecutionRequest) error); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionManager_DeleteWorkflowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflowExecution'
type ExecutionManager_DeleteWorkflowExecution_Call struct {
	*mock.Call
}

// DeleteWorkflowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.DeleteWorkflowExecutionRequest
func (_e *ExecutionManager_Expecter) DeleteWorkflowExecution(ctx interface{}, request interface{}) *ExecutionManager_DeleteWorkflowExecution_Call {
	return &ExecutionManager_DeleteWorkflowExecution_Call{Call: _e.mock.On("DeleteWorkflowExecution", ctx, request)}
}

func (_c *ExecutionManager_DeleteWorkflowExecution_Call) Run(run func(ctx context.Context, request *persistence.DeleteWorkflowExecutionRequest)) *ExecutionManager_DeleteWorkflowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.DeleteWorkflowExecutionRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.DeleteWorkflowExecutionRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_DeleteWorkflowExecution_Call) Return(err error) *ExecutionManager_DeleteWorkflowExecution_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionManager_DeleteWorkflowExecution_Call) RunAndReturn(run func(ctx context.Context, request *persistence.DeleteWorkflowExecutionRequest) error) *ExecutionManager_DeleteWorkflowExecution_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveClusterSelectionPolicy provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetActiveClusterSelectionPolicy(ctx context.Context, domainID string, wfID string, rID string) (*types.ActiveClusterSelectionPolicy, error) {
	ret := _mock.Called(ctx, domainID, wfID, rID)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveClusterSelectionPolicy")
	}

	var r0 *types.ActiveClusterSelectionPolicy
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*types.ActiveClusterSelectionPolicy, error)); ok {
		return returnFunc(ctx, domainID, wfID, rID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *types.ActiveClusterSelectionPolicy); ok {
		r0 = returnFunc(ctx, domainID, wfID, rID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ActiveClusterSelectionPolicy)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, domainID, wfID, rID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_GetActiveClusterSelectionPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveClusterSelectionPolicy'
type ExecutionManager_GetActiveClusterSelectionPolicy_Call struct {
	*mock.Call
}

// GetActiveClusterSelectionPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - wfID string
//   - rID string
func (_e *ExecutionManager_Expecter) GetActiveClusterSelectionPolicy(ctx interface{}, domainID interface{}, wfID interface{}, rID interface{}) *ExecutionManager_GetActiveClusterSelectionPolicy_Call {
	return &ExecutionManager_GetActiveClusterSelectionPolicy_Call{Call: _e.mock.On("GetActiveClusterSelectionPolicy", ctx, domainID, wfID, rID)}
}

func (_c *ExecutionManager_GetActiveClusterSelectionPolicy_Call) Run(run func(ctx context.Context, domainID string, wfID string, rID string)) *ExecutionManager_GetActiveClusterSelectionPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ExecutionManager_GetActiveClusterSelectionPolicy_Call) Return(activeClusterSelectionPolicy *types.ActiveClusterSelectionPolicy, err error) *ExecutionManager_GetActiveClusterSelectionPolicy_Call {
	_c.Call.Return(activeClusterSelectionPolicy, err)
	return _c
}

func (_c *ExecutionManager_GetActiveClusterSelectionPolicy_Call) RunAndReturn(run func(ctx context.Context, domainID string, wfID string, rID string) (*types.ActiveClusterSelectionPolicy, error)) *ExecutionManager_GetActiveClusterSelectionPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentExecution provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetCurrentExecution(ctx context.Context, request *persistence.GetCurrentExecutionRequest) (*persistence.GetCurrentExecutionResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentExecution")
	}

	var r0 *persistence.GetCurrentExecutionResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetCurrentExecutionRequest) (*persistence.GetCurrentExecutionResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetCurrentExecutionRequest) *persistence.GetCurrentExecutionResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.GetCurrentExecutionResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.GetCurrentExecutionRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_GetCurrentExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentExecution'
type ExecutionManager_GetCurrentExecution_Call struct {
	*mock.Call
}

// GetCurrentExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.GetCurrentExecutionRequest
func (_e *ExecutionManager_Expecter) GetCurrentExecution(ctx interface{}, request interface{}) *ExecutionManager_GetCurrentExecution_Call {
	return &ExecutionManager_GetCurrentExecution_Call{Call: _e.mock.On("GetCurrentExecution", ctx, request)}
}

func (_c *ExecutionManager_GetCurrentExecution_Call) Run(run func(ctx context.Context, request *persistence.GetCurrentExecutionRequest)) *ExecutionManager_GetCurrentExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.GetCurrentExecutionRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.GetCurrentExecutionRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_GetCurrentExecution_Call) Return(getCurrentExecutionResponse *persistence.GetCurrentExecutionResponse, err error) *ExecutionManager_GetCurrentExecution_Call {
	_c.Call.Return(getCurrentExecutionResponse, err)
	return _c
}

func (_c *ExecutionManager_GetCurrentExecution_Call) RunAndReturn(run func(ctx context.Context, request *persistence.GetCurrentExecutionRequest) (*persistence.GetCurrentExecutionResponse, error)) *ExecutionManager_GetCurrentExecution_Call {
	_c.Call.Return(run)
	return _c
}

// GetHistoryTasks provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetHistoryTasks(ctx context.Context, request *persistence.GetHistoryTasksRequest) (*persistence.GetHistoryTasksResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetHistoryTasks")
	}

	var r0 *persistence.GetHistoryTasksResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetHistoryTasksRequest) (*persistence.GetHistoryTasksResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetHistoryTasksRequest) *persistence.GetHistoryTasksResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.GetHistoryTasksResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.GetHistoryTasksRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_GetHistoryTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHistoryTasks'
type ExecutionManager_GetHistoryTasks_Call struct {
	*mock.Call
}

// GetHistoryTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.GetHistoryTasksRequest
func (_e *ExecutionManager_Expecter) GetHistoryTasks(ctx interface{}, request interface{}) *ExecutionManager_GetHistoryTasks_Call {
	return &ExecutionManager_GetHistoryTasks_Call{Call: _e.mock.On("GetHistoryTasks", ctx, request)}
}

func (_c *ExecutionManager_GetHistoryTasks_Call) Run(run func(ctx context.Context, request *persistence.GetHistoryTasksRequest)) *ExecutionManager_GetHistoryTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.GetHistoryTasksRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.GetHistoryTasksRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_GetHistoryTasks_Call) Return(getHistoryTasksResponse *persistence.GetHistoryTasksResponse, err error) *ExecutionManager_GetHistoryTasks_Call {
	_c.Call.Return(getHistoryTasksResponse, err)
	return _c
}

func (_c *ExecutionManager_GetHistoryTasks_Call) RunAndReturn(run func(ctx context.Context, request *persistence.GetHistoryTasksRequest) (*persistence.GetHistoryTasksResponse, error)) *ExecutionManager_GetHistoryTasks_Call {
	_c.Call.Return(run)
	return _c
}

// GetName provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetName() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetName")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// ExecutionManager_GetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetName'
type ExecutionManager_GetName_Call struct {
	*mock.Call
}

// GetName is a helper method to define mock.On call
func (_e *ExecutionManager_Expecter) GetName() *ExecutionManager_GetName_Call {
	return &ExecutionManager_GetName_Call{Call: _e.mock.On("GetName")}
}

func (_c *ExecutionManager_GetName_Call) Run(run func()) *ExecutionManager_GetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionManager_GetName_Call) Return(s string) *ExecutionManager_GetName_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *ExecutionManager_GetName_Call) RunAndReturn(run func() string) *ExecutionManager_GetName_Call {
	_c.Call.Return(run)
	return _c
}

// GetReplicationDLQSize provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetReplicationDLQSize(ctx context.Context, request *persistence.GetReplicationDLQSizeRequest) (*persistence.GetReplicationDLQSizeResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetReplicationDLQSize")
	}

	var r0 *persistence.GetReplicationDLQSizeResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetReplicationDLQSizeRequest) (*persistence.GetReplicationDLQSizeResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetReplicationDLQSizeRequest) *persistence.GetReplicationDLQSizeResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.GetReplicationDLQSizeResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.GetReplicationDLQSizeRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_GetReplicationDLQSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReplicationDLQSize'
type ExecutionManager_GetReplicationDLQSize_Call struct {
	*mock.Call
}

// GetReplicationDLQSize is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.GetReplicationDLQSizeRequest
func (_e *ExecutionManager_Expecter) GetReplicationDLQSize(ctx interface{}, request interface{}) *ExecutionManager_GetReplicationDLQSize_Call {
	return &ExecutionManager_GetReplicationDLQSize_Call{Call: _e.mock.On("GetReplicationDLQSize", ctx, request)}
}

func (_c *ExecutionManager_GetReplicationDLQSize_Call) Run(run func(ctx context.Context, request *persistence.GetReplicationDLQSizeRequest)) *ExecutionManager_GetReplicationDLQSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.GetReplicationDLQSizeRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.GetReplicationDLQSizeRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_GetReplicationDLQSize_Call) Return(getReplicationDLQSizeResponse *persistence.GetReplicationDLQSizeResponse, err error) *ExecutionManager_GetReplicationDLQSize_Call {
	_c.Call.Return(getReplicationDLQSizeResponse, err)
	return _c
}

func (_c *ExecutionManager_GetReplicationDLQSize_Call) RunAndReturn(run func(ctx context.Context, request *persistence.GetReplicationDLQSizeRequest) (*persistence.GetReplicationDLQSizeResponse, error)) *ExecutionManager_GetReplicationDLQSize_Call {
	_c.Call.Return(run)
	return _c
}

// GetReplicationTasksFromDLQ provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetReplicationTasksFromDLQ(ctx context.Context, request *persistence.GetReplicationTasksFromDLQRequest) (*persistence.GetHistoryTasksResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetReplicationTasksFromDLQ")
	}

	var r0 *persistence.GetHistoryTasksResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetReplicationTasksFromDLQRequest) (*persistence.GetHistoryTasksResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetReplicationTasksFromDLQRequest) *persistence.GetHistoryTasksResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.GetHistoryTasksResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.GetReplicationTasksFromDLQRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_GetReplicationTasksFromDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReplicationTasksFromDLQ'
type ExecutionManager_GetReplicationTasksFromDLQ_Call struct {
	*mock.Call
}

// GetReplicationTasksFromDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.GetReplicationTasksFromDLQRequest
func (_e *ExecutionManager_Expecter) GetReplicationTasksFromDLQ(ctx interface{}, request interface{}) *ExecutionManager_GetReplicationTasksFromDLQ_Call {
	return &ExecutionManager_GetReplicationTasksFromDLQ_Call{Call: _e.mock.On("GetReplicationTasksFromDLQ", ctx, request)}
}

func (_c *ExecutionManager_GetReplicationTasksFromDLQ_Call) Run(run func(ctx context.Context, request *persistence.GetReplicationTasksFromDLQRequest)) *ExecutionManager_GetReplicationTasksFromDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.GetReplicationTasksFromDLQRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.GetReplicationTasksFromDLQRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_GetReplicationTasksFromDLQ_Call) Return(getHistoryTasksResponse *persistence.GetHistoryTasksResponse, err error) *ExecutionManager_GetReplicationTasksFromDLQ_Call {
	_c.Call.Return(getHistoryTasksResponse, err)
	return _c
}

func (_c *ExecutionManager_GetReplicationTasksFromDLQ_Call) RunAndReturn(run func(ctx context.Context, request *persistence.GetReplicationTasksFromDLQRequest) (*persistence.GetHistoryTasksResponse, error)) *ExecutionManager_GetReplicationTasksFromDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// GetShardID provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetShardID() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetShardID")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// ExecutionManager_GetShardID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetShardID'
type ExecutionManager_GetShardID_Call struct {
	*mock.Call
}

// GetShardID is a helper method to define mock.On call
func (_e *ExecutionManager_Expecter) GetShardID() *ExecutionManager_GetShardID_Call {
	return &ExecutionManager_GetShardID_Call{Call: _e.mock.On("GetShardID")}
}

func (_c *ExecutionManager_GetShardID_Call) Run(run func()) *ExecutionManager_GetShardID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutionManager_GetShardID_Call) Return(n int) *ExecutionManager_GetShardID_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *ExecutionManager_GetShardID_Call) RunAndReturn(run func() int) *ExecutionManager_GetShardID_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowExecution provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) GetWorkflowExecution(ctx context.Context, request *persistence.GetWorkflowExecutionRequest) (*persistence.GetWorkflowExecutionResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowExecution")
	}

	var r0 *persistence.GetWorkflowExecutionResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetWorkflowExecutionRequest) (*persistence.GetWorkflowExecutionResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.GetWorkflowExecutionRequest) *persistence.GetWorkflowExecutionResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.GetWorkflowExecutionResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.GetWorkflowExecutionRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_GetWorkflowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowExecution'
type ExecutionManager_GetWorkflowExecution_Call struct {
	*mock.Call
}

// GetWorkflowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.GetWorkflowExecutionRequest
func (_e *ExecutionManager_Expecter) GetWorkflowExecution(ctx interface{}, request interface{}) *ExecutionManager_GetWorkflowExecution_Call {
	return &ExecutionManager_GetWorkflowExecution_Call{Call: _e.mock.On("GetWorkflowExecution", ctx, request)}
}

func (_c *ExecutionManager_GetWorkflowExecution_Call) Run(run func(ctx context.Context, request *persistence.GetWorkflowExecutionRequest)) *ExecutionManager_GetWorkflowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.GetWorkflowExecutionRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.GetWorkflowExecutionRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_GetWorkflowExecution_Call) Return(getWorkflowExecutionResponse *persistence.GetWorkflowExecutionResponse, err error) *ExecutionManager_GetWorkflowExecution_Call {
	_c.Call.Return(getWorkflowExecutionResponse, err)
	return _c
}

func (_c *ExecutionManager_GetWorkflowExecution_Call) RunAndReturn(run func(ctx context.Context, request *persistence.GetWorkflowExecutionRequest) (*persistence.GetWorkflowExecutionResponse, error)) *ExecutionManager_GetWorkflowExecution_Call {
	_c.Call.Return(run)
	return _c
}

// IsWorkflowExecutionExists provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) IsWorkflowExecutionExists(ctx context.Context, request *persistence.IsWorkflowExecutionExistsRequest) (*persistence.IsWorkflowExecutionExistsResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for IsWorkflowExecutionExists")
	}

	var r0 *persistence.IsWorkflowExecutionExistsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.IsWorkflowExecutionExistsRequest) (*persistence.IsWorkflowExecutionExistsResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.IsWorkflowExecutionExistsRequest) *persistence.IsWorkflowExecutionExistsResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.IsWorkflowExecutionExistsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.IsWorkflowExecutionExistsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_IsWorkflowExecutionExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsWorkflowExecutionExists'
type ExecutionManager_IsWorkflowExecutionExists_Call struct {
	*mock.Call
}

// IsWorkflowExecutionExists is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.IsWorkflowExecutionExistsRequest
func (_e *ExecutionManager_Expecter) IsWorkflowExecutionExists(ctx interface{}, request interface{}) *ExecutionManager_IsWorkflowExecutionExists_Call {
	return &ExecutionManager_IsWorkflowExecutionExists_Call{Call: _e.mock.On("IsWorkflowExecutionExists", ctx, request)}
}

func (_c *ExecutionManager_IsWorkflowExecutionExists_Call) Run(run func(ctx context.Context, request *persistence.IsWorkflowExecutionExistsRequest)) *ExecutionManager_IsWorkflowExecutionExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.IsWorkflowExecutionExistsRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.IsWorkflowExecutionExistsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_IsWorkflowExecutionExists_Call) Return(isWorkflowExecutionExistsResponse *persistence.IsWorkflowExecutionExistsResponse, err error) *ExecutionManager_IsWorkflowExecutionExists_Call {
	_c.Call.Return(isWorkflowExecutionExistsResponse, err)
	return _c
}

func (_c *ExecutionManager_IsWorkflowExecutionExists_Call) RunAndReturn(run func(ctx context.Context, request *persistence.IsWorkflowExecutionExistsRequest) (*persistence.IsWorkflowExecutionExistsResponse, error)) *ExecutionManager_IsWorkflowExecutionExists_Call {
	_c.Call.Return(run)
	return _c
}

// ListConcreteExecutions provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) ListConcreteExecutions(ctx context.Context, request *persistence.ListConcreteExecutionsRequest) (*persistence.ListConcreteExecutionsResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListConcreteExecutions")
	}

	var r0 *persistence.ListConcreteExecutionsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.ListConcreteExecutionsRequest) (*persistence.ListConcreteExecutionsResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.ListConcreteExecutionsRequest) *persistence.ListConcreteExecutionsResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.ListConcreteExecutionsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.ListConcreteExecutionsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_ListConcreteExecutions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListConcreteExecutions'
type ExecutionManager_ListConcreteExecutions_Call struct {
	*mock.Call
}

// ListConcreteExecutions is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.ListConcreteExecutionsRequest
func (_e *ExecutionManager_Expecter) ListConcreteExecutions(ctx interface{}, request interface{}) *ExecutionManager_ListConcreteExecutions_Call {
	return &ExecutionManager_ListConcreteExecutions_Call{Call: _e.mock.On("ListConcreteExecutions", ctx, request)}
}

func (_c *ExecutionManager_ListConcreteExecutions_Call) Run(run func(ctx context.Context, request *persistence.ListConcreteExecutionsRequest)) *ExecutionManager_ListConcreteExecutions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.ListConcreteExecutionsRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.ListConcreteExecutionsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_ListConcreteExecutions_Call) Return(listConcreteExecutionsResponse *persistence.ListConcreteExecutionsResponse, err error) *ExecutionManager_ListConcreteExecutions_Call {
	_c.Call.Return(listConcreteExecutionsResponse, err)
	return _c
}

func (_c *ExecutionManager_ListConcreteExecutions_Call) RunAndReturn(run func(ctx context.Context, request *persistence.ListConcreteExecutionsRequest) (*persistence.ListConcreteExecutionsResponse, error)) *ExecutionManager_ListConcreteExecutions_Call {
	_c.Call.Return(run)
	return _c
}

// ListCurrentExecutions provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) ListCurrentExecutions(ctx context.Context, request *persistence.ListCurrentExecutionsRequest) (*persistence.ListCurrentExecutionsResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListCurrentExecutions")
	}

	var r0 *persistence.ListCurrentExecutionsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.ListCurrentExecutionsRequest) (*persistence.ListCurrentExecutionsResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.ListCurrentExecutionsRequest) *persistence.ListCurrentExecutionsResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.ListCurrentExecutionsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.ListCurrentExecutionsRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_ListCurrentExecutions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCurrentExecutions'
type ExecutionManager_ListCurrentExecutions_Call struct {
	*mock.Call
}

// ListCurrentExecutions is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.ListCurrentExecutionsRequest
func (_e *ExecutionManager_Expecter) ListCurrentExecutions(ctx interface{}, request interface{}) *ExecutionManager_ListCurrentExecutions_Call {
	return &ExecutionManager_ListCurrentExecutions_Call{Call: _e.mock.On("ListCurrentExecutions", ctx, request)}
}

func (_c *ExecutionManager_ListCurrentExecutions_Call) Run(run func(ctx context.Context, request *persistence.ListCurrentExecutionsRequest)) *ExecutionManager_ListCurrentExecutions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.ListCurrentExecutionsRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.ListCurrentExecutionsRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_ListCurrentExecutions_Call) Return(listCurrentExecutionsResponse *persistence.ListCurrentExecutionsResponse, err error) *ExecutionManager_ListCurrentExecutions_Call {
	_c.Call.Return(listCurrentExecutionsResponse, err)
	return _c
}

func (_c *ExecutionManager_ListCurrentExecutions_Call) RunAndReturn(run func(ctx context.Context, request *persistence.ListCurrentExecutionsRequest) (*persistence.ListCurrentExecutionsResponse, error)) *ExecutionManager_ListCurrentExecutions_Call {
	_c.Call.Return(run)
	return _c
}

// PutReplicationTaskToDLQ provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) PutReplicationTaskToDLQ(ctx context.Context, request *persistence.PutReplicationTaskToDLQRequest) error {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for PutReplicationTaskToDLQ")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.PutReplicationTaskToDLQRequest) error); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExecutionManager_PutReplicationTaskToDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutReplicationTaskToDLQ'
type ExecutionManager_PutReplicationTaskToDLQ_Call struct {
	*mock.Call
}

// PutReplicationTaskToDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.PutReplicationTaskToDLQRequest
func (_e *ExecutionManager_Expecter) PutReplicationTaskToDLQ(ctx interface{}, request interface{}) *ExecutionManager_PutReplicationTaskToDLQ_Call {
	return &ExecutionManager_PutReplicationTaskToDLQ_Call{Call: _e.mock.On("PutReplicationTaskToDLQ", ctx, request)}
}

func (_c *ExecutionManager_PutReplicationTaskToDLQ_Call) Run(run func(ctx context.Context, request *persistence.PutReplicationTaskToDLQRequest)) *ExecutionManager_PutReplicationTaskToDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.PutReplicationTaskToDLQRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.PutReplicationTaskToDLQRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_PutReplicationTaskToDLQ_Call) Return(err error) *ExecutionManager_PutReplicationTaskToDLQ_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExecutionManager_PutReplicationTaskToDLQ_Call) RunAndReturn(run func(ctx context.Context, request *persistence.PutReplicationTaskToDLQRequest) error) *ExecutionManager_PutReplicationTaskToDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// RangeCompleteHistoryTask provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) RangeCompleteHistoryTask(ctx context.Context, request *persistence.RangeCompleteHistoryTaskRequest) (*persistence.RangeCompleteHistoryTaskResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for RangeCompleteHistoryTask")
	}

	var r0 *persistence.RangeCompleteHistoryTaskResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.RangeCompleteHistoryTaskRequest) (*persistence.RangeCompleteHistoryTaskResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.RangeCompleteHistoryTaskRequest) *persistence.RangeCompleteHistoryTaskResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.RangeCompleteHistoryTaskResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.RangeCompleteHistoryTaskRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_RangeCompleteHistoryTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RangeCompleteHistoryTask'
type ExecutionManager_RangeCompleteHistoryTask_Call struct {
	*mock.Call
}

// RangeCompleteHistoryTask is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.RangeCompleteHistoryTaskRequest
func (_e *ExecutionManager_Expecter) RangeCompleteHistoryTask(ctx interface{}, request interface{}) *ExecutionManager_RangeCompleteHistoryTask_Call {
	return &ExecutionManager_RangeCompleteHistoryTask_Call{Call: _e.mock.On("RangeCompleteHistoryTask", ctx, request)}
}

func (_c *ExecutionManager_RangeCompleteHistoryTask_Call) Run(run func(ctx context.Context, request *persistence.RangeCompleteHistoryTaskRequest)) *ExecutionManager_RangeCompleteHistoryTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.RangeCompleteHistoryTaskRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.RangeCompleteHistoryTaskRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_RangeCompleteHistoryTask_Call) Return(rangeCompleteHistoryTaskResponse *persistence.RangeCompleteHistoryTaskResponse, err error) *ExecutionManager_RangeCompleteHistoryTask_Call {
	_c.Call.Return(rangeCompleteHistoryTaskResponse, err)
	return _c
}

func (_c *ExecutionManager_RangeCompleteHistoryTask_Call) RunAndReturn(run func(ctx context.Context, request *persistence.RangeCompleteHistoryTaskRequest) (*persistence.RangeCompleteHistoryTaskResponse, error)) *ExecutionManager_RangeCompleteHistoryTask_Call {
	_c.Call.Return(run)
	return _c
}

// RangeDeleteReplicationTaskFromDLQ provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) RangeDeleteReplicationTaskFromDLQ(ctx context.Context, request *persistence.RangeDeleteReplicationTaskFromDLQRequest) (*persistence.RangeDeleteReplicationTaskFromDLQResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for RangeDeleteReplicationTaskFromDLQ")
	}

	var r0 *persistence.RangeDeleteReplicationTaskFromDLQResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.RangeDeleteReplicationTaskFromDLQRequest) (*persistence.RangeDeleteReplicationTaskFromDLQResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.RangeDeleteReplicationTaskFromDLQRequest) *persistence.RangeDeleteReplicationTaskFromDLQResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.RangeDeleteReplicationTaskFromDLQResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.RangeDeleteReplicationTaskFromDLQRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RangeDeleteReplicationTaskFromDLQ'
type ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call struct {
	*mock.Call
}

// RangeDeleteReplicationTaskFromDLQ is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.RangeDeleteReplicationTaskFromDLQRequest
func (_e *ExecutionManager_Expecter) RangeDeleteReplicationTaskFromDLQ(ctx interface{}, request interface{}) *ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call {
	return &ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call{Call: _e.mock.On("RangeDeleteReplicationTaskFromDLQ", ctx, request)}
}

func (_c *ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call) Run(run func(ctx context.Context, request *persistence.RangeDeleteReplicationTaskFromDLQRequest)) *ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.RangeDeleteReplicationTaskFromDLQRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.RangeDeleteReplicationTaskFromDLQRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call) Return(rangeDeleteReplicationTaskFromDLQResponse *persistence.RangeDeleteReplicationTaskFromDLQResponse, err error) *ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call {
	_c.Call.Return(rangeDeleteReplicationTaskFromDLQResponse, err)
	return _c
}

func (_c *ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call) RunAndReturn(run func(ctx context.Context, request *persistence.RangeDeleteReplicationTaskFromDLQRequest) (*persistence.RangeDeleteReplicationTaskFromDLQResponse, error)) *ExecutionManager_RangeDeleteReplicationTaskFromDLQ_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflowExecution provides a mock function for the type ExecutionManager
func (_mock *ExecutionManager) UpdateWorkflowExecution(ctx context.Context, request *persistence.UpdateWorkflowExecutionRequest) (*persistence.UpdateWorkflowExecutionResponse, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflowExecution")
	}

	var r0 *persistence.UpdateWorkflowExecutionResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.UpdateWorkflowExecutionRequest) (*persistence.UpdateWorkflowExecutionResponse, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *persistence.UpdateWorkflowExecutionRequest) *persistence.UpdateWorkflowExecutionResponse); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*persistence.UpdateWorkflowExecutionResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *persistence.UpdateWorkflowExecutionRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExecutionManager_UpdateWorkflowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflowExecution'
type ExecutionManager_UpdateWorkflowExecution_Call struct {
	*mock.Call
}

// UpdateWorkflowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *persistence.UpdateWorkflowExecutionRequest
func (_e *ExecutionManager_Expecter) UpdateWorkflowExecution(ctx interface{}, request interface{}) *ExecutionManager_UpdateWorkflowExecution_Call {
	return &ExecutionManager_UpdateWorkflowExecution_Call{Call: _e.mock.On("UpdateWorkflowExecution", ctx, request)}
}

func (_c *ExecutionManager_UpdateWorkflowExecution_Call) Run(run func(ctx context.Context, request *persistence.UpdateWorkflowExecutionRequest)) *ExecutionManager_UpdateWorkflowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *persistence.UpdateWorkflowExecutionRequest
		if args[1] != nil {
			arg1 = args[1].(*persistence.UpdateWorkflowExecutionRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExecutionManager_UpdateWorkflowExecution_Call) Return(updateWorkflowExecutionResponse *persistence.UpdateWorkflowExecutionResponse, err error) *ExecutionManager_UpdateWorkflowExecution_Call {
	_c.Call.Return(updateWorkflowExecutionResponse, err)
	return _c
}

func (_c *ExecutionManager_UpdateWorkflowExecution_Call) RunAndReturn(run func(ctx context.Context, request *persistence.UpdateWorkflowExecutionRequest) (*persistence.UpdateWorkflowExecutionResponse, error)) *ExecutionManager_UpdateWorkflowExecution_Call {
	_c.Call.Return(run)
	return _c
}
