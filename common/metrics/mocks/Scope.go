// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"time"

	mock "github.com/stretchr/testify/mock"

	"github.com/uber/cadence/common/metrics"
)

// NewScope creates a new instance of Scope. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewScope(t interface {
	mock.TestingT
	Cleanup(func())
}) *Scope {
	mock := &Scope{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Scope is an autogenerated mock type for the Scope type
type Scope struct {
	mock.Mock
}

type Scope_Expecter struct {
	mock *mock.Mock
}

func (_m *Scope) EXPECT() *Scope_Expecter {
	return &Scope_Expecter{mock: &_m.Mock}
}

// AddCounter provides a mock function for the type Scope
func (_mock *Scope) AddCounter(counter metrics.MetricIdx, delta int64) {
	_mock.Called(counter, delta)
	return
}

// Scope_AddCounter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCounter'
type Scope_AddCounter_Call struct {
	*mock.Call
}

// AddCounter is a helper method to define mock.On call
//   - counter metrics.MetricIdx
//   - delta int64
func (_e *Scope_Expecter) AddCounter(counter interface{}, delta interface{}) *Scope_AddCounter_Call {
	return &Scope_AddCounter_Call{Call: _e.mock.On("AddCounter", counter, delta)}
}

func (_c *Scope_AddCounter_Call) Run(run func(counter metrics.MetricIdx, delta int64)) *Scope_AddCounter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Scope_AddCounter_Call) Return() *Scope_AddCounter_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_AddCounter_Call) RunAndReturn(run func(counter metrics.MetricIdx, delta int64)) *Scope_AddCounter_Call {
	_c.Run(run)
	return _c
}

// ExponentialHistogram provides a mock function for the type Scope
func (_mock *Scope) ExponentialHistogram(hist metrics.MetricIdx, d time.Duration) {
	_mock.Called(hist, d)
	return
}

// Scope_ExponentialHistogram_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExponentialHistogram'
type Scope_ExponentialHistogram_Call struct {
	*mock.Call
}

// ExponentialHistogram is a helper method to define mock.On call
//   - hist metrics.MetricIdx
//   - d time.Duration
func (_e *Scope_Expecter) ExponentialHistogram(hist interface{}, d interface{}) *Scope_ExponentialHistogram_Call {
	return &Scope_ExponentialHistogram_Call{Call: _e.mock.On("ExponentialHistogram", hist, d)}
}

func (_c *Scope_ExponentialHistogram_Call) Run(run func(hist metrics.MetricIdx, d time.Duration)) *Scope_ExponentialHistogram_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Scope_ExponentialHistogram_Call) Return() *Scope_ExponentialHistogram_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_ExponentialHistogram_Call) RunAndReturn(run func(hist metrics.MetricIdx, d time.Duration)) *Scope_ExponentialHistogram_Call {
	_c.Run(run)
	return _c
}

// IncCounter provides a mock function for the type Scope
func (_mock *Scope) IncCounter(counter metrics.MetricIdx) {
	_mock.Called(counter)
	return
}

// Scope_IncCounter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncCounter'
type Scope_IncCounter_Call struct {
	*mock.Call
}

// IncCounter is a helper method to define mock.On call
//   - counter metrics.MetricIdx
func (_e *Scope_Expecter) IncCounter(counter interface{}) *Scope_IncCounter_Call {
	return &Scope_IncCounter_Call{Call: _e.mock.On("IncCounter", counter)}
}

func (_c *Scope_IncCounter_Call) Run(run func(counter metrics.MetricIdx)) *Scope_IncCounter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Scope_IncCounter_Call) Return() *Scope_IncCounter_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_IncCounter_Call) RunAndReturn(run func(counter metrics.MetricIdx)) *Scope_IncCounter_Call {
	_c.Run(run)
	return _c
}

// IntExponentialHistogram provides a mock function for the type Scope
func (_mock *Scope) IntExponentialHistogram(hist metrics.MetricIdx, value int) {
	_mock.Called(hist, value)
	return
}

// Scope_IntExponentialHistogram_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IntExponentialHistogram'
type Scope_IntExponentialHistogram_Call struct {
	*mock.Call
}

// IntExponentialHistogram is a helper method to define mock.On call
//   - hist metrics.MetricIdx
//   - value int
func (_e *Scope_Expecter) IntExponentialHistogram(hist interface{}, value interface{}) *Scope_IntExponentialHistogram_Call {
	return &Scope_IntExponentialHistogram_Call{Call: _e.mock.On("IntExponentialHistogram", hist, value)}
}

func (_c *Scope_IntExponentialHistogram_Call) Run(run func(hist metrics.MetricIdx, value int)) *Scope_IntExponentialHistogram_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Scope_IntExponentialHistogram_Call) Return() *Scope_IntExponentialHistogram_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_IntExponentialHistogram_Call) RunAndReturn(run func(hist metrics.MetricIdx, value int)) *Scope_IntExponentialHistogram_Call {
	_c.Run(run)
	return _c
}

// RecordHistogramDuration provides a mock function for the type Scope
func (_mock *Scope) RecordHistogramDuration(timer metrics.MetricIdx, d time.Duration) {
	_mock.Called(timer, d)
	return
}

// Scope_RecordHistogramDuration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistogramDuration'
type Scope_RecordHistogramDuration_Call struct {
	*mock.Call
}

// RecordHistogramDuration is a helper method to define mock.On call
//   - timer metrics.MetricIdx
//   - d time.Duration
func (_e *Scope_Expecter) RecordHistogramDuration(timer interface{}, d interface{}) *Scope_RecordHistogramDuration_Call {
	return &Scope_RecordHistogramDuration_Call{Call: _e.mock.On("RecordHistogramDuration", timer, d)}
}

func (_c *Scope_RecordHistogramDuration_Call) Run(run func(timer metrics.MetricIdx, d time.Duration)) *Scope_RecordHistogramDuration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Scope_RecordHistogramDuration_Call) Return() *Scope_RecordHistogramDuration_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_RecordHistogramDuration_Call) RunAndReturn(run func(timer metrics.MetricIdx, d time.Duration)) *Scope_RecordHistogramDuration_Call {
	_c.Run(run)
	return _c
}

// RecordHistogramValue provides a mock function for the type Scope
func (_mock *Scope) RecordHistogramValue(timer metrics.MetricIdx, value float64) {
	_mock.Called(timer, value)
	return
}

// Scope_RecordHistogramValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistogramValue'
type Scope_RecordHistogramValue_Call struct {
	*mock.Call
}

// RecordHistogramValue is a helper method to define mock.On call
//   - timer metrics.MetricIdx
//   - value float64
func (_e *Scope_Expecter) RecordHistogramValue(timer interface{}, value interface{}) *Scope_RecordHistogramValue_Call {
	return &Scope_RecordHistogramValue_Call{Call: _e.mock.On("RecordHistogramValue", timer, value)}
}

func (_c *Scope_RecordHistogramValue_Call) Run(run func(timer metrics.MetricIdx, value float64)) *Scope_RecordHistogramValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		var arg1 float64
		if args[1] != nil {
			arg1 = args[1].(float64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Scope_RecordHistogramValue_Call) Return() *Scope_RecordHistogramValue_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_RecordHistogramValue_Call) RunAndReturn(run func(timer metrics.MetricIdx, value float64)) *Scope_RecordHistogramValue_Call {
	_c.Run(run)
	return _c
}

// RecordTimer provides a mock function for the type Scope
func (_mock *Scope) RecordTimer(timer metrics.MetricIdx, d time.Duration) {
	_mock.Called(timer, d)
	return
}

// Scope_RecordTimer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordTimer'
type Scope_RecordTimer_Call struct {
	*mock.Call
}

// RecordTimer is a helper method to define mock.On call
//   - timer metrics.MetricIdx
//   - d time.Duration
func (_e *Scope_Expecter) RecordTimer(timer interface{}, d interface{}) *Scope_RecordTimer_Call {
	return &Scope_RecordTimer_Call{Call: _e.mock.On("RecordTimer", timer, d)}
}

func (_c *Scope_RecordTimer_Call) Run(run func(timer metrics.MetricIdx, d time.Duration)) *Scope_RecordTimer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Scope_RecordTimer_Call) Return() *Scope_RecordTimer_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_RecordTimer_Call) RunAndReturn(run func(timer metrics.MetricIdx, d time.Duration)) *Scope_RecordTimer_Call {
	_c.Run(run)
	return _c
}

// StartTimer provides a mock function for the type Scope
func (_mock *Scope) StartTimer(timer metrics.MetricIdx) metrics.Stopwatch {
	ret := _mock.Called(timer)

	if len(ret) == 0 {
		panic("no return value specified for StartTimer")
	}

	var r0 metrics.Stopwatch
	if returnFunc, ok := ret.Get(0).(func(metrics.MetricIdx) metrics.Stopwatch); ok {
		r0 = returnFunc(timer)
	} else {
		r0 = ret.Get(0).(metrics.Stopwatch)
	}
	return r0
}

// Scope_StartTimer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartTimer'
type Scope_StartTimer_Call struct {
	*mock.Call
}

// StartTimer is a helper method to define mock.On call
//   - timer metrics.MetricIdx
func (_e *Scope_Expecter) StartTimer(timer interface{}) *Scope_StartTimer_Call {
	return &Scope_StartTimer_Call{Call: _e.mock.On("StartTimer", timer)}
}

func (_c *Scope_StartTimer_Call) Run(run func(timer metrics.MetricIdx)) *Scope_StartTimer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Scope_StartTimer_Call) Return(stopwatch metrics.Stopwatch) *Scope_StartTimer_Call {
	_c.Call.Return(stopwatch)
	return _c
}

func (_c *Scope_StartTimer_Call) RunAndReturn(run func(timer metrics.MetricIdx) metrics.Stopwatch) *Scope_StartTimer_Call {
	_c.Call.Return(run)
	return _c
}

// Tagged provides a mock function for the type Scope
func (_mock *Scope) Tagged(tags ...metrics.Tag) metrics.Scope {
	var tmpRet mock.Arguments
	if len(tags) > 0 {
		tmpRet = _mock.Called(tags)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Tagged")
	}

	var r0 metrics.Scope
	if returnFunc, ok := ret.Get(0).(func(...metrics.Tag) metrics.Scope); ok {
		r0 = returnFunc(tags...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metrics.Scope)
		}
	}
	return r0
}

// Scope_Tagged_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tagged'
type Scope_Tagged_Call struct {
	*mock.Call
}

// Tagged is a helper method to define mock.On call
//   - tags ...metrics.Tag
func (_e *Scope_Expecter) Tagged(tags ...interface{}) *Scope_Tagged_Call {
	return &Scope_Tagged_Call{Call: _e.mock.On("Tagged",
		append([]interface{}{}, tags...)...)}
}

func (_c *Scope_Tagged_Call) Run(run func(tags ...metrics.Tag)) *Scope_Tagged_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []metrics.Tag
		var variadicArgs []metrics.Tag
		if len(args) > 0 {
			variadicArgs = args[0].([]metrics.Tag)
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *Scope_Tagged_Call) Return(scope metrics.Scope) *Scope_Tagged_Call {
	_c.Call.Return(scope)
	return _c
}

func (_c *Scope_Tagged_Call) RunAndReturn(run func(tags ...metrics.Tag) metrics.Scope) *Scope_Tagged_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGauge provides a mock function for the type Scope
func (_mock *Scope) UpdateGauge(gauge metrics.MetricIdx, value float64) {
	_mock.Called(gauge, value)
	return
}

// Scope_UpdateGauge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGauge'
type Scope_UpdateGauge_Call struct {
	*mock.Call
}

// UpdateGauge is a helper method to define mock.On call
//   - gauge metrics.MetricIdx
//   - value float64
func (_e *Scope_Expecter) UpdateGauge(gauge interface{}, value interface{}) *Scope_UpdateGauge_Call {
	return &Scope_UpdateGauge_Call{Call: _e.mock.On("UpdateGauge", gauge, value)}
}

func (_c *Scope_UpdateGauge_Call) Run(run func(gauge metrics.MetricIdx, value float64)) *Scope_UpdateGauge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.MetricIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.MetricIdx)
		}
		var arg1 float64
		if args[1] != nil {
			arg1 = args[1].(float64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Scope_UpdateGauge_Call) Return() *Scope_UpdateGauge_Call {
	_c.Call.Return()
	return _c
}

func (_c *Scope_UpdateGauge_Call) RunAndReturn(run func(gauge metrics.MetricIdx, value float64)) *Scope_UpdateGauge_Call {
	_c.Run(run)
	return _c
}
