// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package archiver

import (
	"context"

	mock "github.com/stretchr/testify/mock"
)

// NewHistoryArchiverMock creates a new instance of HistoryArchiverMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHistoryArchiverMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *HistoryArchiverMock {
	mock := &HistoryArchiverMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HistoryArchiverMock is an autogenerated mock type for the HistoryArchiver type
type HistoryArchiverMock struct {
	mock.Mock
}

type HistoryArchiverMock_Expecter struct {
	mock *mock.Mock
}

func (_m *HistoryArchiverMock) EXPECT() *HistoryArchiverMock_Expecter {
	return &HistoryArchiverMock_Expecter{mock: &_m.Mock}
}

// Archive provides a mock function for the type HistoryArchiverMock
func (_mock *HistoryArchiverMock) Archive(context1 context.Context, uRI URI, archiveHistoryRequest *ArchiveHistoryRequest, archiveOptions ...ArchiveOption) error {
	var tmpRet mock.Arguments
	if len(archiveOptions) > 0 {
		tmpRet = _mock.Called(context1, uRI, archiveHistoryRequest, archiveOptions)
	} else {
		tmpRet = _mock.Called(context1, uRI, archiveHistoryRequest)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Archive")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, URI, *ArchiveHistoryRequest, ...ArchiveOption) error); ok {
		r0 = returnFunc(context1, uRI, archiveHistoryRequest, archiveOptions...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// HistoryArchiverMock_Archive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Archive'
type HistoryArchiverMock_Archive_Call struct {
	*mock.Call
}

// Archive is a helper method to define mock.On call
//   - context1 context.Context
//   - uRI URI
//   - archiveHistoryRequest *ArchiveHistoryRequest
//   - archiveOptions ...ArchiveOption
func (_e *HistoryArchiverMock_Expecter) Archive(context1 interface{}, uRI interface{}, archiveHistoryRequest interface{}, archiveOptions ...interface{}) *HistoryArchiverMock_Archive_Call {
	return &HistoryArchiverMock_Archive_Call{Call: _e.mock.On("Archive",
		append([]interface{}{context1, uRI, archiveHistoryRequest}, archiveOptions...)...)}
}

func (_c *HistoryArchiverMock_Archive_Call) Run(run func(context1 context.Context, uRI URI, archiveHistoryRequest *ArchiveHistoryRequest, archiveOptions ...ArchiveOption)) *HistoryArchiverMock_Archive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 URI
		if args[1] != nil {
			arg1 = args[1].(URI)
		}
		var arg2 *ArchiveHistoryRequest
		if args[2] != nil {
			arg2 = args[2].(*ArchiveHistoryRequest)
		}
		var arg3 []ArchiveOption
		var variadicArgs []ArchiveOption
		if len(args) > 3 {
			variadicArgs = args[3].([]ArchiveOption)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *HistoryArchiverMock_Archive_Call) Return(err error) *HistoryArchiverMock_Archive_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *HistoryArchiverMock_Archive_Call) RunAndReturn(run func(context1 context.Context, uRI URI, archiveHistoryRequest *ArchiveHistoryRequest, archiveOptions ...ArchiveOption) error) *HistoryArchiverMock_Archive_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type HistoryArchiverMock
func (_mock *HistoryArchiverMock) Get(context1 context.Context, uRI URI, getHistoryRequest *GetHistoryRequest) (*GetHistoryResponse, error) {
	ret := _mock.Called(context1, uRI, getHistoryRequest)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *GetHistoryResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, URI, *GetHistoryRequest) (*GetHistoryResponse, error)); ok {
		return returnFunc(context1, uRI, getHistoryRequest)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, URI, *GetHistoryRequest) *GetHistoryResponse); ok {
		r0 = returnFunc(context1, uRI, getHistoryRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetHistoryResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, URI, *GetHistoryRequest) error); ok {
		r1 = returnFunc(context1, uRI, getHistoryRequest)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HistoryArchiverMock_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type HistoryArchiverMock_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - context1 context.Context
//   - uRI URI
//   - getHistoryRequest *GetHistoryRequest
func (_e *HistoryArchiverMock_Expecter) Get(context1 interface{}, uRI interface{}, getHistoryRequest interface{}) *HistoryArchiverMock_Get_Call {
	return &HistoryArchiverMock_Get_Call{Call: _e.mock.On("Get", context1, uRI, getHistoryRequest)}
}

func (_c *HistoryArchiverMock_Get_Call) Run(run func(context1 context.Context, uRI URI, getHistoryRequest *GetHistoryRequest)) *HistoryArchiverMock_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 URI
		if args[1] != nil {
			arg1 = args[1].(URI)
		}
		var arg2 *GetHistoryRequest
		if args[2] != nil {
			arg2 = args[2].(*GetHistoryRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *HistoryArchiverMock_Get_Call) Return(getHistoryResponse *GetHistoryResponse, err error) *HistoryArchiverMock_Get_Call {
	_c.Call.Return(getHistoryResponse, err)
	return _c
}

func (_c *HistoryArchiverMock_Get_Call) RunAndReturn(run func(context1 context.Context, uRI URI, getHistoryRequest *GetHistoryRequest) (*GetHistoryResponse, error)) *HistoryArchiverMock_Get_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateURI provides a mock function for the type HistoryArchiverMock
func (_mock *HistoryArchiverMock) ValidateURI(uRI URI) error {
	ret := _mock.Called(uRI)

	if len(ret) == 0 {
		panic("no return value specified for ValidateURI")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(URI) error); ok {
		r0 = returnFunc(uRI)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// HistoryArchiverMock_ValidateURI_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateURI'
type HistoryArchiverMock_ValidateURI_Call struct {
	*mock.Call
}

// ValidateURI is a helper method to define mock.On call
//   - uRI URI
func (_e *HistoryArchiverMock_Expecter) ValidateURI(uRI interface{}) *HistoryArchiverMock_ValidateURI_Call {
	return &HistoryArchiverMock_ValidateURI_Call{Call: _e.mock.On("ValidateURI", uRI)}
}

func (_c *HistoryArchiverMock_ValidateURI_Call) Run(run func(uRI URI)) *HistoryArchiverMock_ValidateURI_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 URI
		if args[0] != nil {
			arg0 = args[0].(URI)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *HistoryArchiverMock_ValidateURI_Call) Return(err error) *HistoryArchiverMock_ValidateURI_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *HistoryArchiverMock_ValidateURI_Call) RunAndReturn(run func(uRI URI) error) *HistoryArchiverMock_ValidateURI_Call {
	_c.Call.Return(run)
	return _c
}

// NewVisibilityArchiverMock creates a new instance of VisibilityArchiverMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewVisibilityArchiverMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *VisibilityArchiverMock {
	mock := &VisibilityArchiverMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// VisibilityArchiverMock is an autogenerated mock type for the VisibilityArchiver type
type VisibilityArchiverMock struct {
	mock.Mock
}

type VisibilityArchiverMock_Expecter struct {
	mock *mock.Mock
}

func (_m *VisibilityArchiverMock) EXPECT() *VisibilityArchiverMock_Expecter {
	return &VisibilityArchiverMock_Expecter{mock: &_m.Mock}
}

// Archive provides a mock function for the type VisibilityArchiverMock
func (_mock *VisibilityArchiverMock) Archive(context1 context.Context, uRI URI, archiveVisibilityRequest *ArchiveVisibilityRequest, archiveOptions ...ArchiveOption) error {
	var tmpRet mock.Arguments
	if len(archiveOptions) > 0 {
		tmpRet = _mock.Called(context1, uRI, archiveVisibilityRequest, archiveOptions)
	} else {
		tmpRet = _mock.Called(context1, uRI, archiveVisibilityRequest)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Archive")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, URI, *ArchiveVisibilityRequest, ...ArchiveOption) error); ok {
		r0 = returnFunc(context1, uRI, archiveVisibilityRequest, archiveOptions...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// VisibilityArchiverMock_Archive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Archive'
type VisibilityArchiverMock_Archive_Call struct {
	*mock.Call
}

// Archive is a helper method to define mock.On call
//   - context1 context.Context
//   - uRI URI
//   - archiveVisibilityRequest *ArchiveVisibilityRequest
//   - archiveOptions ...ArchiveOption
func (_e *VisibilityArchiverMock_Expecter) Archive(context1 interface{}, uRI interface{}, archiveVisibilityRequest interface{}, archiveOptions ...interface{}) *VisibilityArchiverMock_Archive_Call {
	return &VisibilityArchiverMock_Archive_Call{Call: _e.mock.On("Archive",
		append([]interface{}{context1, uRI, archiveVisibilityRequest}, archiveOptions...)...)}
}

func (_c *VisibilityArchiverMock_Archive_Call) Run(run func(context1 context.Context, uRI URI, archiveVisibilityRequest *ArchiveVisibilityRequest, archiveOptions ...ArchiveOption)) *VisibilityArchiverMock_Archive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 URI
		if args[1] != nil {
			arg1 = args[1].(URI)
		}
		var arg2 *ArchiveVisibilityRequest
		if args[2] != nil {
			arg2 = args[2].(*ArchiveVisibilityRequest)
		}
		var arg3 []ArchiveOption
		var variadicArgs []ArchiveOption
		if len(args) > 3 {
			variadicArgs = args[3].([]ArchiveOption)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *VisibilityArchiverMock_Archive_Call) Return(err error) *VisibilityArchiverMock_Archive_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *VisibilityArchiverMock_Archive_Call) RunAndReturn(run func(context1 context.Context, uRI URI, archiveVisibilityRequest *ArchiveVisibilityRequest, archiveOptions ...ArchiveOption) error) *VisibilityArchiverMock_Archive_Call {
	_c.Call.Return(run)
	return _c
}

// Query provides a mock function for the type VisibilityArchiverMock
func (_mock *VisibilityArchiverMock) Query(context1 context.Context, uRI URI, queryVisibilityRequest *QueryVisibilityRequest) (*QueryVisibilityResponse, error) {
	ret := _mock.Called(context1, uRI, queryVisibilityRequest)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 *QueryVisibilityResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, URI, *QueryVisibilityRequest) (*QueryVisibilityResponse, error)); ok {
		return returnFunc(context1, uRI, queryVisibilityRequest)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, URI, *QueryVisibilityRequest) *QueryVisibilityResponse); ok {
		r0 = returnFunc(context1, uRI, queryVisibilityRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*QueryVisibilityResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, URI, *QueryVisibilityRequest) error); ok {
		r1 = returnFunc(context1, uRI, queryVisibilityRequest)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// VisibilityArchiverMock_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type VisibilityArchiverMock_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - context1 context.Context
//   - uRI URI
//   - queryVisibilityRequest *QueryVisibilityRequest
func (_e *VisibilityArchiverMock_Expecter) Query(context1 interface{}, uRI interface{}, queryVisibilityRequest interface{}) *VisibilityArchiverMock_Query_Call {
	return &VisibilityArchiverMock_Query_Call{Call: _e.mock.On("Query", context1, uRI, queryVisibilityRequest)}
}

func (_c *VisibilityArchiverMock_Query_Call) Run(run func(context1 context.Context, uRI URI, queryVisibilityRequest *QueryVisibilityRequest)) *VisibilityArchiverMock_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 URI
		if args[1] != nil {
			arg1 = args[1].(URI)
		}
		var arg2 *QueryVisibilityRequest
		if args[2] != nil {
			arg2 = args[2].(*QueryVisibilityRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *VisibilityArchiverMock_Query_Call) Return(queryVisibilityResponse *QueryVisibilityResponse, err error) *VisibilityArchiverMock_Query_Call {
	_c.Call.Return(queryVisibilityResponse, err)
	return _c
}

func (_c *VisibilityArchiverMock_Query_Call) RunAndReturn(run func(context1 context.Context, uRI URI, queryVisibilityRequest *QueryVisibilityRequest) (*QueryVisibilityResponse, error)) *VisibilityArchiverMock_Query_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateURI provides a mock function for the type VisibilityArchiverMock
func (_mock *VisibilityArchiverMock) ValidateURI(uRI URI) error {
	ret := _mock.Called(uRI)

	if len(ret) == 0 {
		panic("no return value specified for ValidateURI")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(URI) error); ok {
		r0 = returnFunc(uRI)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// VisibilityArchiverMock_ValidateURI_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateURI'
type VisibilityArchiverMock_ValidateURI_Call struct {
	*mock.Call
}

// ValidateURI is a helper method to define mock.On call
//   - uRI URI
func (_e *VisibilityArchiverMock_Expecter) ValidateURI(uRI interface{}) *VisibilityArchiverMock_ValidateURI_Call {
	return &VisibilityArchiverMock_ValidateURI_Call{Call: _e.mock.On("ValidateURI", uRI)}
}

func (_c *VisibilityArchiverMock_ValidateURI_Call) Run(run func(uRI URI)) *VisibilityArchiverMock_ValidateURI_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 URI
		if args[0] != nil {
			arg0 = args[0].(URI)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *VisibilityArchiverMock_ValidateURI_Call) Return(err error) *VisibilityArchiverMock_ValidateURI_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *VisibilityArchiverMock_ValidateURI_Call) RunAndReturn(run func(uRI URI) error) *VisibilityArchiverMock_ValidateURI_Call {
	_c.Call.Return(run)
	return _c
}
