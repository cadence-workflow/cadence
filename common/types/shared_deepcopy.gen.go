// generated by deep-copy -o ./shared_deepcopy.gen.go -type DescribeDomainResponse -type BadBinaries -type DataBlob -type ActiveClusters .; DO NOT EDIT.

package types

// DeepCopy generates a deep copy of DescribeDomainResponse
func (o DescribeDomainResponse) DeepCopy() DescribeDomainResponse {
	var cp DescribeDomainResponse = o
	if o.DomainInfo != nil {
		cp.DomainInfo = new(DomainInfo)
		*cp.DomainInfo = *o.DomainInfo
		if o.DomainInfo.Status != nil {
			cp.DomainInfo.Status = new(DomainStatus)
			*cp.DomainInfo.Status = *o.DomainInfo.Status
		}
		if o.DomainInfo.Data != nil {
			cp.DomainInfo.Data = make(map[string]string, len(o.DomainInfo.Data))
			for k4, v4 := range o.DomainInfo.Data {
				cp.DomainInfo.Data[k4] = v4
			}
		}
	}
	if o.Configuration != nil {
		cp.Configuration = new(DomainConfiguration)
		*cp.Configuration = *o.Configuration
		if o.Configuration.BadBinaries != nil {
			cp.Configuration.BadBinaries = o.Configuration.BadBinaries.DeepCopy()
		}
		if o.Configuration.HistoryArchivalStatus != nil {
			cp.Configuration.HistoryArchivalStatus = new(ArchivalStatus)
			*cp.Configuration.HistoryArchivalStatus = *o.Configuration.HistoryArchivalStatus
		}
		if o.Configuration.VisibilityArchivalStatus != nil {
			cp.Configuration.VisibilityArchivalStatus = new(ArchivalStatus)
			*cp.Configuration.VisibilityArchivalStatus = *o.Configuration.VisibilityArchivalStatus
		}
		if o.Configuration.IsolationGroups != nil {
			retV := o.Configuration.IsolationGroups.DeepCopy()
			cp.Configuration.IsolationGroups = &retV
		}
		if o.Configuration.AsyncWorkflowConfig != nil {
			retV := o.Configuration.AsyncWorkflowConfig.DeepCopy()
			cp.Configuration.AsyncWorkflowConfig = &retV
		}
	}
	if o.ReplicationConfiguration != nil {
		cp.ReplicationConfiguration = new(DomainReplicationConfiguration)
		*cp.ReplicationConfiguration = *o.ReplicationConfiguration
		if o.ReplicationConfiguration.Clusters != nil {
			cp.ReplicationConfiguration.Clusters = make([]*ClusterReplicationConfiguration, len(o.ReplicationConfiguration.Clusters))
			copy(cp.ReplicationConfiguration.Clusters, o.ReplicationConfiguration.Clusters)
			for i4 := range o.ReplicationConfiguration.Clusters {
				if o.ReplicationConfiguration.Clusters[i4] != nil {
					cp.ReplicationConfiguration.Clusters[i4] = new(ClusterReplicationConfiguration)
					*cp.ReplicationConfiguration.Clusters[i4] = *o.ReplicationConfiguration.Clusters[i4]
				}
			}
		}
		if o.ReplicationConfiguration.ActiveClusters != nil {
			cp.ReplicationConfiguration.ActiveClusters = o.ReplicationConfiguration.ActiveClusters.DeepCopy()
		}
	}
	if o.FailoverInfo != nil {
		cp.FailoverInfo = new(FailoverInfo)
		*cp.FailoverInfo = *o.FailoverInfo
		if o.FailoverInfo.PendingShards != nil {
			cp.FailoverInfo.PendingShards = make([]int32, len(o.FailoverInfo.PendingShards))
			copy(cp.FailoverInfo.PendingShards, o.FailoverInfo.PendingShards)
		}
	}
	return cp
}

// DeepCopy generates a deep copy of BadBinaries
func (o BadBinaries) DeepCopy() BadBinaries {
	var cp BadBinaries = o
	if o.Binaries != nil {
		cp.Binaries = make(map[string]*BadBinaryInfo, len(o.Binaries))
		for k2, v2 := range o.Binaries {
			var cp_Binaries_v2 *BadBinaryInfo
			if v2 != nil {
				cp_Binaries_v2 = new(BadBinaryInfo)
				*cp_Binaries_v2 = *v2
				if v2.CreatedTimeNano != nil {
					cp_Binaries_v2.CreatedTimeNano = new(int64)
					*cp_Binaries_v2.CreatedTimeNano = *v2.CreatedTimeNano
				}
			}
			cp.Binaries[k2] = cp_Binaries_v2
		}
	}
	return cp
}

// DeepCopy generates a deep copy of DataBlob
func (o DataBlob) DeepCopy() DataBlob {
	var cp DataBlob = o
	if o.EncodingType != nil {
		cp.EncodingType = new(EncodingType)
		*cp.EncodingType = *o.EncodingType
	}
	if o.Data != nil {
		cp.Data = make([]byte, len(o.Data))
		copy(cp.Data, o.Data)
	}
	return cp
}

// DeepCopy generates a deep copy of ActiveClusters
func (o ActiveClusters) DeepCopy() ActiveClusters {
	var cp ActiveClusters = o
	if o.AttributeScopes != nil {
		cp.AttributeScopes = make(map[string]ClusterAttributeScope, len(o.AttributeScopes))
		for k2, v2 := range o.AttributeScopes {
			var cp_AttributeScopes_v2 ClusterAttributeScope
			if v2.ClusterAttributes != nil {
				cp_AttributeScopes_v2.ClusterAttributes = make(map[string]ActiveClusterInfo, len(v2.ClusterAttributes))
				for k4, v4 := range v2.ClusterAttributes {
					cp_AttributeScopes_v2.ClusterAttributes[k4] = v4
				}
			}
			cp.AttributeScopes[k2] = cp_AttributeScopes_v2
		}
	}
	return cp
}
