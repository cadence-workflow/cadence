(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{394:function(e,t,a){"use strict";a.r(t);var s=a(8),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"fault-oblivious-stateful-workflow-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fault-oblivious-stateful-workflow-code"}},[e._v("#")]),e._v(" Fault-oblivious stateful workflow code")]),e._v(" "),a("h2",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),a("p",[e._v("Cadence core abstraction is a "),a("strong",[e._v("fault-oblivious stateful :workflow:")]),e._v(". The state of the :workflow: code, including local variables and threads it creates, is immune to process and Cadence service failures.\nThis is a very powerful concept as it encapsulates state, processing threads, durable timers and :event: handlers.")]),e._v(" "),a("h2",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example")]),e._v(" "),a("p",[e._v("Let's look at a use case. A customer signs up for an application with a trial period. After the period, if the customer has not cancelled, he should be charged once a month for the renewal. The customer has to be notified by email about the charges and should be able to cancel the subscription at any time.")]),e._v(" "),a("p",[e._v("The business logic of this use case is not very complicated and can be expressed in a few dozen lines of code. But any practical implementation has to ensure that the business process is fault tolerant and scalable. There are various ways to approach the design of such a system.")]),e._v(" "),a("p",[e._v("One approach is to center it around a database. An application process would periodically scan database tables for customers in specific states, execute necessary actions, and update the state to reflect that. While feasible, this approach has various drawbacks. The most obvious is that the state machine of the customer state quickly becomes extremely complicated. For example, charging a credit card or sending emails can fail due to a downstream system unavailability. The failed calls might need to be retried for a long time, ideally using an exponential retry policy. These calls should be throttled to not overload external systems. There should be support for poison pills to avoid blocking the whole process if a single customer record cannot be processed for whatever reason. The database-based approach also usually has performance problems. Databases are not efficient for scenarios that require constant polling for records in a specific state.")]),e._v(" "),a("p",[e._v("Another commonly employed approach is to use a timer service and queues. Any update is pushed to a queue and then a :worker: that consumes from it updates a database and possibly pushes more messages in downstream queues. For operations that require scheduling, an external timer service can be used. This approach usually scales much better because a database is not constantly polled for changes. But it makes the programming model more complex and error prone as usually there is no transactional update between a queuing system and a database.")]),e._v(" "),a("p",[e._v("With Cadence, the entire logic can be encapsulated in a simple durable function that directly implements the business logic. Because the function is stateful, the implementer doesn't need to employ any additional systems to ensure durability and fault tolerance.")]),e._v(" "),a("p",[e._v("Here is an example :workflow: that implements the subscription management use case. It is in Java, but Go is also supported. The Python and .NET libraries are under active development.")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("interface")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SubscriptionWorkflow")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@WorkflowMethod")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("execute")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),e._v(" customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SubscriptionWorkflowImpl")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("implements")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SubscriptionWorkflow")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("private")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("final")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SubscriptionActivities")]),e._v(" activities "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Workflow")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("newActivityStub")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("SubscriptionActivities")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@Override")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("execute")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),e._v(" customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    activities"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sendWelcomeEmail")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("try")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v(" trialPeriod "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("while")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Workflow")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sleep")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Duration")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("ofDays")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("30")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        activities"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("chargeMonthlyFee")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("trialPeriod"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n          activities"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sendEndOfTrialEmail")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n          trialPeriod "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n          activities"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sendMonthlyChargeEmail")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("catch")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("CancellationException")]),e._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      activities"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("processSubscriptionCancellation")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n      activities"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sendSorryToSeeYouGoEmail")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("customerId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Again, note that this code directly implements the business logic. If any of the invoked operations (aka :activity:activities:) takes a long time, the code is not going to change. It is okay to block on "),a("code",[e._v("chargeMonthlyFee")]),e._v(" for a day if the downstream processing service is down that long. The same way that blocking sleep for 30 days is a normal operation inside the :workflow: code.")]),e._v(" "),a("p",[e._v("Cadence has practically no scalability limits on the number of open :workflow: instances. So even if your site has hundreds of millions of consumers, the above code is not going to change.")]),e._v(" "),a("p",[e._v('The commonly asked question by developers that learn Cadence is "How do I handle :workflow_worker: process failure/restart in my :workflow:"? The answer is that you do not. '),a("strong",[e._v("The :workflow: code is completely oblivious to any failures and downtime of :worker:workers: or even the Cadence service itself")]),e._v(". As soon as they are recovered and the :workflow: needs to handle some :event:, like timer or an :activity: completion, the current state of the :workflow: is fully restored and the execution is continued. The only reason for a :workflow: failure is the :workflow: business code throwing an exception, not underlying infrastructure outages.")]),e._v(" "),a("p",[e._v("Another commonly asked question is whether a :worker: can handle more :workflow: instances than its cache size or number of threads it can support. The answer is that a :workflow:, when in a blocked state, can be safely removed from a :worker:.\nLater it can be resurrected on a different or the same :worker: when the need (in the form of an external :event:) arises. So a single :worker: can handle millions of open :workflow_execution:workflow_executions:, assuming it can handle the update rate.")]),e._v(" "),a("h2",{attrs:{id:"state-recovery-and-determinism"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-recovery-and-determinism"}},[e._v("#")]),e._v(" State Recovery and Determinism")]),e._v(" "),a("p",[e._v("The :workflow: state recovery utilizes :event: sourcing which puts a few restrictions on how the code is written. The main restriction is that the :workflow: code must be deterministic which means that it must produce exactly the same result if executed multiple times. This rules out any external API calls from the :workflow: code as external calls can fail intermittently or change its output any time. That is why all communication with the external world should happen through :activity:activities:. For the same reason, :workflow: code must use Cadence APIs to get current time, sleep, and create new threads.")]),e._v(" "),a("p",[e._v("To understand the Cadence execution model as well as the recovery mechanism, watch the following webcast. The animation covering recovery starts at 15:50.")]),e._v(" "),a("figure",{staticClass:"video-container"},[a("iframe",{attrs:{src:"https://www.youtube.com/embed/qce_AqCkFys?start=960",frameborder:"0",height:"315",allowfullscreen:"",width:"560"}})]),e._v(" "),a("h2",{attrs:{id:"id-uniqueness"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#id-uniqueness"}},[e._v("#")]),e._v(" ID Uniqueness")]),e._v(" "),a("p",[e._v(":workflow_ID:Workflow_ID: is assigned by a client when starting a :workflow:. It is usually a business level ID like customer ID or order ID.")]),e._v(" "),a("p",[e._v("Cadence guarantees that there could be only one :workflow: (across all :workflow: types) with a given ID open per :domain: at any time. An attempt to start a :workflow: with the same ID is going to fail with "),a("code",[e._v("WorkflowExecutionAlreadyStarted")]),e._v(" error.")]),e._v(" "),a("p",[e._v("An attempt to start a :workflow: if there is a completed :workflow: with the same ID depends on a "),a("code",[e._v("WorkflowIdReusePolicy")]),e._v(" option:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("AllowDuplicateFailedOnly")]),e._v(" means that it is allowed to start a :workflow: only if a previously executed :workflow: with the same ID failed.")]),e._v(" "),a("li",[a("code",[e._v("AllowDuplicate")]),e._v(" means that it is allowed to start independently of the previous :workflow: completion status.")]),e._v(" "),a("li",[a("code",[e._v("RejectDuplicate")]),e._v(" means that it is not allowed to start a :workflow_execution: using the same :workflow_ID: at all.")])]),e._v(" "),a("p",[e._v("The default is "),a("code",[e._v("AllowDuplicateFailedOnly")]),e._v(".")]),e._v(" "),a("p",[e._v("To distinguish multiple runs of a :workflow: with the same :workflow_ID:, Cadence identifies a :workflow: with two IDs: "),a("code",[e._v("Workflow ID")]),e._v(" and "),a("code",[e._v("Run ID")]),e._v(". "),a("code",[e._v("Run ID")]),e._v(" is a service-assigned UUID. To be precise, any :workflow: is uniquely identified by a triple: "),a("code",[e._v("Domain Name")]),e._v(", "),a("code",[e._v("Workflow ID")]),e._v(" and "),a("code",[e._v("Run ID")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"child-workflow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#child-workflow"}},[e._v("#")]),e._v(" Child Workflow")]),e._v(" "),a("p",[e._v("A :workflow: can execute other :workflow:workflows: as "),a("code",[e._v("child :workflow:workflows:")]),e._v(". A child :workflow: completion or failure is reported to its parent.")]),e._v(" "),a("p",[e._v("Some reasons to use child :workflow:workflows: are:")]),e._v(" "),a("ul",[a("li",[e._v("A child :workflow: can be hosted by a separate set of :worker:workers: which don't contain the parent :workflow: code. So it would act as a separate service that can be invoked from multiple other :workflow:workflows:.")]),e._v(" "),a("li",[e._v("A single :workflow: has a limited size. For example, it cannot execute 100k :activity:activities:. Child :workflow:workflows: can be used to partition the problem into smaller chunks. One parent with 1000 children each executing 1000 :activity:activities: is 1 million executed :activity:activities:.")]),e._v(" "),a("li",[e._v("A child :workflow: can be used to manage some resource using its ID to guarantee uniqueness. For example, a :workflow: that manages host upgrades can have a child :workflow: per host (host name being a :workflow_ID:) and use them to ensure that all operations on the host are serialized.")]),e._v(" "),a("li",[e._v("A child :workflow: can be used to execute some periodic logic without blowing up the parent history size. When a parent starts a child, it executes periodic logic calling that continues as many times as needed, then completes. From the parent point if view, it is just a single child :workflow: invocation.")])]),e._v(" "),a("p",[e._v("The main limitation of a child :workflow: versus collocating all the application logic in a single :workflow: is lack of the shared state. Parent and child can communicate only through asynchronous :signal:signals:. But if there is a tight coupling between them, it might be simpler to use a single :workflow: and just rely on a shared object state.")]),e._v(" "),a("p",[e._v("We recommended starting from a single :workflow: implementation if your problem has bounded size in terms of number of executed :activity:activities: and processed :signal:signals:. It is more straightforward than multiple asynchronously communicating :workflow:workflows:.")]),e._v(" "),a("h2",{attrs:{id:"workflow-retries"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#workflow-retries"}},[e._v("#")]),e._v(" Workflow Retries")]),e._v(" "),a("p",[e._v(":workflow:Workflow: code is unaffected by infrastructure level downtime and failures. But it still can fail due to business logic level failures. For example, an :activity: can fail due to exceeding the retry interval and the error is not handled by application code, or the :workflow: code having a bug.")]),e._v(" "),a("p",[e._v("Some :workflow:workflows: require a guarantee that they keep running even in presence of such failures. To support such use cases, an optional exponential "),a("em",[e._v("retry policy")]),e._v(" can be specified when starting a :workflow:. When it is specified, a :workflow: failure restarts a :workflow: from the beginning after the calculated retry interval. Following are the retry policy parameters:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("InitialInterval")]),e._v(" is a delay before the first retry.")]),e._v(" "),a("li",[a("code",[e._v("BackoffCoefficient")]),e._v(". Retry policies are exponential. The coefficient specifies how fast the retry interval is growing. The coefficient of 1 means that the retry interval is always equal to the "),a("code",[e._v("InitialInterval")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("MaximumInterval")]),e._v(" specifies the maximum interval between retries. Useful for coefficients of more than 1.")]),e._v(" "),a("li",[a("code",[e._v("MaximumAttempts")]),e._v(" specifies how many times to attempt to execute a :workflow: in the presence of failures. If this limit is exceeded, the :workflow: fails without retry. Not required if "),a("code",[e._v("ExpirationInterval")]),e._v(" is specified.")]),e._v(" "),a("li",[a("code",[e._v("ExpirationInterval")]),e._v(" specifies for how long to attempt executing a :workflow: in the presence of failures. If this interval is exceeded, the :workflow: fails without retry. Not required if "),a("code",[e._v("MaximumAttempts")]),e._v(" is specified.")]),e._v(" "),a("li",[a("code",[e._v("NonRetryableErrorReasons")]),e._v(" allows to specify errors that shouldn't be retried. For example, retrying invalid arguments error doesn't make sense in some scenarios.")])])])}),[],!1,null,null,null);t.default=o.exports}}]);