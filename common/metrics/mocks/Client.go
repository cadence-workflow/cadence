// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"time"

	mock "github.com/stretchr/testify/mock"
	"github.com/uber-go/tally"

	"github.com/uber/cadence/common/metrics"
)

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// AddCounter provides a mock function for the type Client
func (_mock *Client) AddCounter(scope metrics.ScopeIdx, counter metrics.MetricIdx, delta int64) {
	_mock.Called(scope, counter, delta)
	return
}

// Client_AddCounter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCounter'
type Client_AddCounter_Call struct {
	*mock.Call
}

// AddCounter is a helper method to define mock.On call
//   - scope metrics.ScopeIdx
//   - counter metrics.MetricIdx
//   - delta int64
func (_e *Client_Expecter) AddCounter(scope interface{}, counter interface{}, delta interface{}) *Client_AddCounter_Call {
	return &Client_AddCounter_Call{Call: _e.mock.On("AddCounter", scope, counter, delta)}
}

func (_c *Client_AddCounter_Call) Run(run func(scope metrics.ScopeIdx, counter metrics.MetricIdx, delta int64)) *Client_AddCounter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.ScopeIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.ScopeIdx)
		}
		var arg1 metrics.MetricIdx
		if args[1] != nil {
			arg1 = args[1].(metrics.MetricIdx)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_AddCounter_Call) Return() *Client_AddCounter_Call {
	_c.Call.Return()
	return _c
}

func (_c *Client_AddCounter_Call) RunAndReturn(run func(scope metrics.ScopeIdx, counter metrics.MetricIdx, delta int64)) *Client_AddCounter_Call {
	_c.Run(run)
	return _c
}

// IncCounter provides a mock function for the type Client
func (_mock *Client) IncCounter(scope metrics.ScopeIdx, counter metrics.MetricIdx) {
	_mock.Called(scope, counter)
	return
}

// Client_IncCounter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncCounter'
type Client_IncCounter_Call struct {
	*mock.Call
}

// IncCounter is a helper method to define mock.On call
//   - scope metrics.ScopeIdx
//   - counter metrics.MetricIdx
func (_e *Client_Expecter) IncCounter(scope interface{}, counter interface{}) *Client_IncCounter_Call {
	return &Client_IncCounter_Call{Call: _e.mock.On("IncCounter", scope, counter)}
}

func (_c *Client_IncCounter_Call) Run(run func(scope metrics.ScopeIdx, counter metrics.MetricIdx)) *Client_IncCounter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.ScopeIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.ScopeIdx)
		}
		var arg1 metrics.MetricIdx
		if args[1] != nil {
			arg1 = args[1].(metrics.MetricIdx)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_IncCounter_Call) Return() *Client_IncCounter_Call {
	_c.Call.Return()
	return _c
}

func (_c *Client_IncCounter_Call) RunAndReturn(run func(scope metrics.ScopeIdx, counter metrics.MetricIdx)) *Client_IncCounter_Call {
	_c.Run(run)
	return _c
}

// RecordHistogramDuration provides a mock function for the type Client
func (_mock *Client) RecordHistogramDuration(scope metrics.ScopeIdx, timer metrics.MetricIdx, d time.Duration) {
	_mock.Called(scope, timer, d)
	return
}

// Client_RecordHistogramDuration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistogramDuration'
type Client_RecordHistogramDuration_Call struct {
	*mock.Call
}

// RecordHistogramDuration is a helper method to define mock.On call
//   - scope metrics.ScopeIdx
//   - timer metrics.MetricIdx
//   - d time.Duration
func (_e *Client_Expecter) RecordHistogramDuration(scope interface{}, timer interface{}, d interface{}) *Client_RecordHistogramDuration_Call {
	return &Client_RecordHistogramDuration_Call{Call: _e.mock.On("RecordHistogramDuration", scope, timer, d)}
}

func (_c *Client_RecordHistogramDuration_Call) Run(run func(scope metrics.ScopeIdx, timer metrics.MetricIdx, d time.Duration)) *Client_RecordHistogramDuration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.ScopeIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.ScopeIdx)
		}
		var arg1 metrics.MetricIdx
		if args[1] != nil {
			arg1 = args[1].(metrics.MetricIdx)
		}
		var arg2 time.Duration
		if args[2] != nil {
			arg2 = args[2].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_RecordHistogramDuration_Call) Return() *Client_RecordHistogramDuration_Call {
	_c.Call.Return()
	return _c
}

func (_c *Client_RecordHistogramDuration_Call) RunAndReturn(run func(scope metrics.ScopeIdx, timer metrics.MetricIdx, d time.Duration)) *Client_RecordHistogramDuration_Call {
	_c.Run(run)
	return _c
}

// RecordTimer provides a mock function for the type Client
func (_mock *Client) RecordTimer(scope metrics.ScopeIdx, timer metrics.MetricIdx, d time.Duration) {
	_mock.Called(scope, timer, d)
	return
}

// Client_RecordTimer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordTimer'
type Client_RecordTimer_Call struct {
	*mock.Call
}

// RecordTimer is a helper method to define mock.On call
//   - scope metrics.ScopeIdx
//   - timer metrics.MetricIdx
//   - d time.Duration
func (_e *Client_Expecter) RecordTimer(scope interface{}, timer interface{}, d interface{}) *Client_RecordTimer_Call {
	return &Client_RecordTimer_Call{Call: _e.mock.On("RecordTimer", scope, timer, d)}
}

func (_c *Client_RecordTimer_Call) Run(run func(scope metrics.ScopeIdx, timer metrics.MetricIdx, d time.Duration)) *Client_RecordTimer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.ScopeIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.ScopeIdx)
		}
		var arg1 metrics.MetricIdx
		if args[1] != nil {
			arg1 = args[1].(metrics.MetricIdx)
		}
		var arg2 time.Duration
		if args[2] != nil {
			arg2 = args[2].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_RecordTimer_Call) Return() *Client_RecordTimer_Call {
	_c.Call.Return()
	return _c
}

func (_c *Client_RecordTimer_Call) RunAndReturn(run func(scope metrics.ScopeIdx, timer metrics.MetricIdx, d time.Duration)) *Client_RecordTimer_Call {
	_c.Run(run)
	return _c
}

// Scope provides a mock function for the type Client
func (_mock *Client) Scope(scope metrics.ScopeIdx, tags ...metrics.Tag) metrics.Scope {
	var tmpRet mock.Arguments
	if len(tags) > 0 {
		tmpRet = _mock.Called(scope, tags)
	} else {
		tmpRet = _mock.Called(scope)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Scope")
	}

	var r0 metrics.Scope
	if returnFunc, ok := ret.Get(0).(func(metrics.ScopeIdx, ...metrics.Tag) metrics.Scope); ok {
		r0 = returnFunc(scope, tags...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metrics.Scope)
		}
	}
	return r0
}

// Client_Scope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scope'
type Client_Scope_Call struct {
	*mock.Call
}

// Scope is a helper method to define mock.On call
//   - scope metrics.ScopeIdx
//   - tags ...metrics.Tag
func (_e *Client_Expecter) Scope(scope interface{}, tags ...interface{}) *Client_Scope_Call {
	return &Client_Scope_Call{Call: _e.mock.On("Scope",
		append([]interface{}{scope}, tags...)...)}
}

func (_c *Client_Scope_Call) Run(run func(scope metrics.ScopeIdx, tags ...metrics.Tag)) *Client_Scope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.ScopeIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.ScopeIdx)
		}
		var arg1 []metrics.Tag
		var variadicArgs []metrics.Tag
		if len(args) > 1 {
			variadicArgs = args[1].([]metrics.Tag)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *Client_Scope_Call) Return(scope1 metrics.Scope) *Client_Scope_Call {
	_c.Call.Return(scope1)
	return _c
}

func (_c *Client_Scope_Call) RunAndReturn(run func(scope metrics.ScopeIdx, tags ...metrics.Tag) metrics.Scope) *Client_Scope_Call {
	_c.Call.Return(run)
	return _c
}

// StartTimer provides a mock function for the type Client
func (_mock *Client) StartTimer(scope metrics.ScopeIdx, timer metrics.MetricIdx) tally.Stopwatch {
	ret := _mock.Called(scope, timer)

	if len(ret) == 0 {
		panic("no return value specified for StartTimer")
	}

	var r0 tally.Stopwatch
	if returnFunc, ok := ret.Get(0).(func(metrics.ScopeIdx, metrics.MetricIdx) tally.Stopwatch); ok {
		r0 = returnFunc(scope, timer)
	} else {
		r0 = ret.Get(0).(tally.Stopwatch)
	}
	return r0
}

// Client_StartTimer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartTimer'
type Client_StartTimer_Call struct {
	*mock.Call
}

// StartTimer is a helper method to define mock.On call
//   - scope metrics.ScopeIdx
//   - timer metrics.MetricIdx
func (_e *Client_Expecter) StartTimer(scope interface{}, timer interface{}) *Client_StartTimer_Call {
	return &Client_StartTimer_Call{Call: _e.mock.On("StartTimer", scope, timer)}
}

func (_c *Client_StartTimer_Call) Run(run func(scope metrics.ScopeIdx, timer metrics.MetricIdx)) *Client_StartTimer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.ScopeIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.ScopeIdx)
		}
		var arg1 metrics.MetricIdx
		if args[1] != nil {
			arg1 = args[1].(metrics.MetricIdx)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_StartTimer_Call) Return(stopwatch tally.Stopwatch) *Client_StartTimer_Call {
	_c.Call.Return(stopwatch)
	return _c
}

func (_c *Client_StartTimer_Call) RunAndReturn(run func(scope metrics.ScopeIdx, timer metrics.MetricIdx) tally.Stopwatch) *Client_StartTimer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGauge provides a mock function for the type Client
func (_mock *Client) UpdateGauge(scope metrics.ScopeIdx, gauge metrics.MetricIdx, value float64) {
	_mock.Called(scope, gauge, value)
	return
}

// Client_UpdateGauge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGauge'
type Client_UpdateGauge_Call struct {
	*mock.Call
}

// UpdateGauge is a helper method to define mock.On call
//   - scope metrics.ScopeIdx
//   - gauge metrics.MetricIdx
//   - value float64
func (_e *Client_Expecter) UpdateGauge(scope interface{}, gauge interface{}, value interface{}) *Client_UpdateGauge_Call {
	return &Client_UpdateGauge_Call{Call: _e.mock.On("UpdateGauge", scope, gauge, value)}
}

func (_c *Client_UpdateGauge_Call) Run(run func(scope metrics.ScopeIdx, gauge metrics.MetricIdx, value float64)) *Client_UpdateGauge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 metrics.ScopeIdx
		if args[0] != nil {
			arg0 = args[0].(metrics.ScopeIdx)
		}
		var arg1 metrics.MetricIdx
		if args[1] != nil {
			arg1 = args[1].(metrics.MetricIdx)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_UpdateGauge_Call) Return() *Client_UpdateGauge_Call {
	_c.Call.Return()
	return _c
}

func (_c *Client_UpdateGauge_Call) RunAndReturn(run func(scope metrics.ScopeIdx, gauge metrics.MetricIdx, value float64)) *Client_UpdateGauge_Call {
	_c.Run(run)
	return _c
}
