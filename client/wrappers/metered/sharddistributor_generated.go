package metered

// Code generated by gowrap. DO NOT EDIT.
// template: ../../templates/metered.tmpl
// gowrap: http://github.com/hexdigest/gowrap

import (
	"context"

	"go.uber.org/yarpc"

	"github.com/uber/cadence/client/sharddistributor"
	"github.com/uber/cadence/common/metrics"
	"github.com/uber/cadence/common/types"
)

// sharddistributorClient implements sharddistributor.Client interface instrumented with retries
type sharddistributorClient struct {
	client        sharddistributor.Client
	metricsClient metrics.Client
}

// NewShardDistributorClient creates a new instance of sharddistributorClient with retry policy
func NewShardDistributorClient(client sharddistributor.Client, metricsClient metrics.Client) sharddistributor.Client {
	return &sharddistributorClient{
		client:        client,
		metricsClient: metricsClient,
	}
}

func (c *sharddistributorClient) GetShardOwner(ctx context.Context, gp1 *types.GetShardOwnerRequest, p1 ...yarpc.CallOption) (gp2 *types.GetShardOwnerResponse, err error) {
	retryCount := getRetryCountFromContext(ctx)

	var scope metrics.Scope
	if retryCount == -1 {
		scope = c.metricsClient.Scope(metrics.ShardDistributorClientGetShardOwnerScope)
	} else {
		scope = c.metricsClient.Scope(metrics.ShardDistributorClientGetShardOwnerScope, metrics.IsRetryTag(retryCount > 0))
	}

	scope.IncCounter(metrics.CadenceClientRequests)

	sw := scope.StartTimer(metrics.CadenceClientLatency)
	gp2, err = c.client.GetShardOwner(ctx, gp1, p1...)
	sw.Stop()

	if err != nil {
		scope.IncCounter(metrics.CadenceClientFailures)
	}
	return gp2, err
}
