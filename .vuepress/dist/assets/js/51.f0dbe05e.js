(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{379:function(t,a,n){"use strict";n.r(a);var s=n(8),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"signals"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#signals"}},[t._v("#")]),t._v(" Signals")]),t._v(" "),n("p",[t._v(":signal:Signals: provide a mechanism to send data directly to a running :workflow:. Previously, you had\ntwo options for passing data to the :workflow: implementation:")]),t._v(" "),n("ul",[n("li",[t._v("Via start parameters")]),t._v(" "),n("li",[t._v("As return values from :activity:activities:")])]),t._v(" "),n("p",[t._v("With start parameters, we could only pass in values before :workflow_execution: began.")]),t._v(" "),n("p",[t._v("Return values from :activity:activities: allowed us to pass information to a running :workflow:, but this\napproach comes with its own complications. One major drawback is reliance on polling. This means\nthat the data needs to be stored in a third-party location until it's ready to be picked up by\nthe :activity:. Further, the lifecycle of this :activity: requires management, and the :activity:\nrequires manual restart if it fails before acquiring the data.")]),t._v(" "),n("p",[t._v(":signal:Signals:, on the other hand, provide a fully asynchronous and durable mechanism for providing data to\na running :workflow:. When a :signal: is received for a running :workflow:, Cadence persists the :event:\nand the payload in the :workflow: history. The :workflow: can then process the :signal: at any time\nafterwards without the risk of losing the information. The :workflow: also has the option to stop\nexecution by blocking on a :signal: channel.")]),t._v(" "),n("div",{staticClass:"language-go extra-class"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" signalVal "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\nsignalChan "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" workflow"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("GetSignalChannel")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ctx"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" signalName"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\ns "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" workflow"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("NewSelector")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ctx"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ns"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("AddReceive")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("signalChan"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c workflow"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Channel"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" more "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    c"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Receive")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ctx"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("signalVal"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    workflow"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("GetLogger")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ctx"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Info")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Received signal!"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" zap"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"signal"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" signalName"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" zap"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" signalVal"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ns"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Select")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ctx"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("signalVal"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" signalVal "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SOME_VALUE"')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" errors"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("New")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"signalVal"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("In the example above, the :workflow: code uses "),n("strong",[t._v("workflow.GetSignalChannel")]),t._v(" to open a\n"),n("strong",[t._v("workflow.Channel")]),t._v(" for the named :signal:. We then use a "),n("strong",[t._v("workflow.Selector")]),t._v(" to wait on this\nchannel and process the payload received with the :signal:.")]),t._v(" "),n("h2",{attrs:{id:"signalwithstart"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#signalwithstart"}},[t._v("#")]),t._v(" SignalWithStart")]),t._v(" "),n("p",[t._v("You may not know if a :workflow: is running and can accept a :signal:. The\n"),n("a",{attrs:{href:"https://godoc.org/go.uber.org/cadence/client#Client",target:"_blank",rel:"noopener noreferrer"}},[t._v("client.SignalWithStartWorkflow"),n("OutboundLink")],1),t._v(" API\nallows you to send a :signal: to the current :workflow: instance if one exists or to create a new\nrun and then send the :signal:. "),n("code",[t._v("SignalWithStartWorkflow")]),t._v(" therefore doesn't take a :run_ID: as a\nparameter.")])])}),[],!1,null,null,null);a.default=e.exports}}]);