(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{410:function(e,t,s){"use strict";s.r(t);var a=s(8),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"task-lists"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#task-lists"}},[e._v("#")]),e._v(" Task lists")]),e._v(" "),s("p",[e._v("When a :workflow: invokes an :activity:, it sends the "),s("code",[e._v("ScheduleActivityTask")]),e._v(" :decision: to the\nCadence service. As a result, the service updates the :workflow: state and dispatches\nan :activity_task: to a :worker: that implements the :activity:.\nInstead of calling the :worker: directly, an intermediate queue is used. So the service adds an "),s("em",[e._v(":activity_task:")]),e._v(" to this\nqueue and a :worker: receives the :task: using a long poll request.\nCadence calls this queue used to dispatch :activity_task:activity_tasks: an "),s("em",[e._v(":activity_task_list:")]),e._v(".")]),e._v(" "),s("p",[e._v("Similarly, when a :workflow: needs to handle an external :event:, a :decision_task: is created.\nA :decision_task_list: is used to deliver it to the :workflow_worker: (also called "),s("em",[e._v("decider")]),e._v(").")]),e._v(" "),s("p",[e._v("While Cadence :task_list:task_lists: are queues, they have some differences from commonly used queuing technologies.\nThe main one is that they do not require explicit registration and are created on demand. The number of :task_list:task_lists:\nis not limited. A common use case is to have a :task_list: per :worker: process and use it to deliver :activity_task:activity_tasks:\nto the process. Another use case is to have a :task_list: per pool of :worker:workers:.")]),e._v(" "),s("p",[e._v("There are multiple advantages of using a :task_list: to deliver :task:tasks: instead of invoking an :activity_worker: through a synchronous RPC:")]),e._v(" "),s("ul",[s("li",[e._v(":worker:Worker: doesn't need to have any open ports, which is more secure.")]),e._v(" "),s("li",[e._v(":worker:Worker: doesn't need to advertise itself through DNS or any other network discovery mechanism.")]),e._v(" "),s("li",[e._v("When all :worker:workers: are down, messages are persisted in a :task_list: waiting for the :worker:workers: to recover.")]),e._v(" "),s("li",[e._v("A :worker: polls for a message only when it has spare capacity, so it never gets overloaded.")]),e._v(" "),s("li",[e._v("Automatic load balancing across a large number of :worker:workers:.")]),e._v(" "),s("li",[e._v(":task_list:Task_lists: support server side throttling. This allows you to limit the :task: dispatch rate to the pool of :worker:workers: and still supports adding a :task: with a higher rate when spikes happen.")]),e._v(" "),s("li",[e._v(":task_list:Task_lists: can be used to route a request to specific pools of :worker:workers: or even a specific process.")])])])}),[],!1,null,null,null);t.default=i.exports}}]);